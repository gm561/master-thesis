%
\newcommand{\prGx}{(\Gamma_V,\Gamma_H) := \langle P^{(1)}(\pi^*), D_1(\rho) \rangle_{P^{(1)}} \\ x^* := \langle P^{(1)}(\pi^*), D_1(\rho) \rangle_{\text{trans}}}
%
We define the following circuit $\widetilde{C}_2$:
\begin{codeblock}
  \textbf{Circuit $\widetilde{C}_2^{\Gamma_V^{(g)}, \Gamma_H^{(g)}, C_2, hash} (x, \rho)$}
  \medskip \hrule \medskip
  \textbf{Oracle:} $\Gamma_V^{(g)}, \Gamma_H^{(k)}, hash, C_2$ \\
  \textbf{Input:} A transcript $x$, a bitstring $\rho$. \\
  \textbf{Output:} A tuple $(q, y_1, \dots, y_k)$ or $\bot$.
  \medskip\hrule\medskip
  Run $C_2^{\Gamma_V^{(g)},\Gamma_H^{(k)}}(x, \rho)$ \\
  \IndI \If $C_2$ asks a hint query on $q$ \then\\
  \IndII \If $q \in P_{hash}$ \then\\
  \IndIII \return $\bot$\\
  \IndII \textbf{else}\\
  \IndIII answer the query using $\Gamma_H^{(k)}(q)$\\
  \\
  \IndI \If $C_2$ asks a verification query $(q, y_1, \dots, y_k)$ \then \\
  \IndII \If $q \in P_{hash}$ \textbf{then} \\
  \IndIII ask a verification query $(q, y_1, \dots, y_k)$ \\
  \IndII \textbf{else} \\
  \IndIII answer the verification query with 0 \\
  \return $\bot$
\end{codeblock}
%
We define a new solver circuit $\widetilde{C} = (C_1, \widetilde{C}_2)$
that in the first phase uses the circuit $C_1$ and in the second phase the circuit $\widetilde{C}_2$.
%
\begin{lemma}
  \label{lemma:ctilda_c}
  For fixed $P^{(g)}, C$ and $hash$ the following statement is true
  \begin{align*}
    \underset{\pi^{(k)}, \rho}{\Pr}[CanonicalSuccess^{P^{(g)}, C, hash}(\pi^{(k)}, \rho) = 1]
    \leq \underset{\pi^{(k)}, \rho}{\Pr}[CanonicalSuccess^{P^{(g)}, \widetilde{C}, hash}(\pi^{(k)}, \rho) = 1]
    % \underset{\substack{ \pi^{(k)}, \rho \\
    %     (\Gamma_V^{(g)}, \Gamma_H^{(k)}) := \langle P^{(g)}(\pi^{(k)}), S(\rho) \rangle_{P^{(g)}} \\
    %     x:= \langle P^{(g)}(\pi^{(k)}), S(\rho) \rangle_{\text{trans}}}}
    % {\Pr}\left[\Gamma_V^{(g)} (\widetilde{C}^{\Gamma_V^{(g)}, \Gamma_H^{(k)}, hash}(x, \rho)) = 1\right].
  \end{align*}
\end{lemma}
%
\begin{proof}
We fix $\pi^{(k)}, \rho$.
If $C$ succeeds canonically then also $\widetilde{C}$ succeeds canonically.
% as in the first phase both
% circuits uses $C_1$, and in the second phase if $C_2$ succeeds canonically, then also $\widetilde{C}_2$ succeeds canonically.
% For $(\Gamma_V^{(g)}, \Gamma_H^{(g)}) := \langle P^{(g)}(\pi^{(k)}), C_1(\rho) \rangle_{P^{(g)}}$ and
% $x := \langle P^{(g)}(\pi^{(k)}), C_1(\rho) \rangle_{\text{trans}}$, $C(\rho)$ succeeds canonically, if and only if
% \begin{align*}
% \Gamma_V^{(g)} (\widetilde{C}_2^{\Gamma_V^{(g)}, \Gamma_H^{(g)}, hash}(x, \rho)) = 1.
% \end{align*}
Using this observation, we conclude that
\begin{align*}
  &\underset{\pi^{(k)}, \rho}{\Pr}\left[CanonicalSuccess^{P^{(g)}, C, hash}(\pi^{(k)}, \rho) = 1\right] \\
  &\IndII = \underset{\pi^{(k)}, \rho}{\mathbb{E}}\left[CanonicalSuccess^{P^{(g)}, C, hash}(\pi^{(k)}, \rho) = 1 \right] \\
  &\IndII \leq \underset{\pi^{(k)}, \rho}{\Pr}\left[CanonicalSuccess^{P^{(g)}, \widetilde{C}, hash}(\pi^{(k)}, \rho) = 1\right]
  % &\IndII = \underset{\substack{\pi^{(k)}, \rho \\
  %     \left(\Gamma_V^{(g)}, \Gamma_H^{(k)}\right) := \langle P^{(g)}(\pi^{(k)}), C_1(\rho) \rangle_{P^{(g)}} \\
  %     x := \langle P^{(g)}(\pi^{(k)}), C_1(\rho) \rangle_{\text{trans}}}}
  % {\Pr}[\Gamma_V^{(g)} (\widetilde{C}^{\Gamma_V^{(g)}, \Gamma_H^{(k)}, hash}(x, \rho)) = 1].
\end{align*}
% hack to have a square at the end of the proof
\\\text{  }
\end{proof}
%
From a circuit $C$ we can build a circuit $\widetilde{C}$ that asks at most one verification query
$(q, y_1, \dots, y_k)$ such that $q \in P_{hash}$, and every hint query on $q$ is such that $q \notin P_{hash}$.
Furthermore, we write $(q, y_1, \dots, y_k) := \widetilde{C}_2(x, \rho)$ to denote
the verification query $(q, y_1, \dots, y_k)$ asked by $\widetilde{C}_2$.
If $\widetilde{C}_2$ does not ask a verification query we write $\bot := \widetilde{C}_2(x, \rho)$.
%
% TODO give justification why we need circuit \widetitle{C}
%
\begin{lemma}\textbf{(Security amplification of a dynamic weakly verifiable puzzle with respect to $P_{hash}$.)}
  \label{lemma:sec_amp_for_p_hash}
  For fixed $P^{(1)}$ there exists an algorithm $Gen$, with oracle access to:
  $P^{(1)}$, a monotone function $g:\{0,1\}^{(k)} \rightarrow \{0,1\}$,
  a solver circuit $C$ for $P^{(g)}$ and a function $hash : Q \rightarrow \{0, \dots, 2(h+v)-1\}$.
  Additionally, $Gen$ takes as input parameters $\varepsilon, \delta, n$,
  the number of verification queries $v$ and hint queries $h$ asked by $C$, the number of puzzles to solve $k$,
  and outputs a solver circuit $D$ for $P^{(1)}$ as in Definition \ref{def:dwvp}
  such that the following holds: \\
  If $C$ is such that \\
  \begin{align*}
    \underset{\pi^{(k)}, \rho}{\Pr}\left[CanonicalSuccess^{P^{(g)}, C, hash}(\pi^{(k)}, \rho)=1\right] \geq \underset{\mu \leftarrow \mu_\delta^k}{\Pr}[g(\mu) = 1] + \varepsilon,
  \end{align*}
  then $D$ satisfies almost surely
  \begin{align*}
    \underset{\pi, \rho}{\Pr}\left[CanonicalSuccess^{P^{(1)}, D, hash}(\pi, \rho)=1\right] \geq (\delta + \frac{\varepsilon}{6k})
  \end{align*}
  Additionally, $D$ requires oracle access to $g$, $P^{(1)}$, $C$,
  Furthermore, $D$ asks at most $\frac{6k}{\epsilon}\log\left(\frac{6k}{\epsilon}\right) h$ hint queries and at most one verification query.
  Finally, $Size(D) \leq Size(C)\frac{6k}{\varepsilon}$ and $Time(Gen) = poly(k, \frac{1}{\varepsilon}, n, v, h)$.
\end{lemma}
%
\begin{proof}
%
First we define the following procedure that returns an estimate for the function $g$ with the first bit set to $b \in \{0,1\}$.
%
\begin{codeblock}
  $\textbf{EvaluateFunctionProbability}^{g}(b, \epsilon, \delta)$
  \medskip
  \hrule
  \medskip
  \textbf{Oracle:} A function $g$.\\
  \textbf{Input:} A bit $b \in \{0,1\}$, parameters $k$, $\epsilon$ \\
  \textbf{Output:} An estimate $\widetilde{g} \in \left[0,1\right]$.
  \medskip\hrule\medskip
  \textbf{For} $i:=1$ to $\frac{16k^2}{\epsilon^2}\log(n)$ \Do \\
  \IndI $(b_2, \dots, b_k) \leftarrow \mu_{\delta}^{(k-1)}$ \\
  \IndI $g_i := g(b,b_2, \dots, b_k)$ \then \\
  \textbf{return} $\frac{\epsilon^2}{16k^2\log(n)} \sum_{i=1}^{\frac{16k^2}{\epsilon^2}\log(n)} g_i$
\end{codeblock}
%
\begin{lemma}[Estimate of the function $g$.]
  \label{lemma:estimate_of_g}
  The procedure \textbf{EvaluteFunctionProbability} outputs an estimate $\widetilde{g}$ for the function $g: \{0,1\}^{n} \rightarrow \{0,1\}$ with the first bit fixed to $b \in \{0,1\}$
  such that $| \widetilde{g} - \underset{(u_2,\dots,u_k) \leftarrow \mu_{\delta}^{k}}{\Pr}\left[g(b,u_2, \dots, u_k) = 1\right] | \leq \frac{\epsilon}{4k}$ almost surely.
\end{lemma}
%
\begin{proof}
We define binary random variable $K_i$ for the event that $g_i = 1$.
By Chernoff bound we get
\begin{align*}
  \underset{}{\Pr}\left[\left|\frac{\epsilon^2 \log(n)}{16k^2} \sum_{i=1}^{\frac{16k^2}{\epsilon^2}\log(n)} \widetilde{g}_i - \mathbb{E}[K_i]\right| \geq \frac{\epsilon}{4k}  \right] \leq 2e^{\log(n)/3}.
\end{align*}
\end{proof}
%
Next we define a procedure \textbf{EvalutePuzzles}$(\pi^{(k)}, \rho)$ that outputs a tuple indicating puzzles are solved successfully
in the random experiment $CanonicalSuccess^{P^{(g)}, \widetilde{C}, hash}(\pi^{(k)}, \rho)$.
%
\begin{codeblock}
  $\textbf{EvaluatePuzzles}^{P^{(1)}, \widetilde{C}, hash}(\pi^{(k)}, \rho)$
  \medskip \hrule \medskip
  \textbf{Oracle:}  A circuit $\widetilde{C}$, an algorithm $P^{(1)}$, a function $hash$.\\
  \textbf{Input:} Bitstrings $\pi^{(k)}$, $\rho$.\\
  \textbf{Output}: A tuple $(c_1, \dots, c_k)$.
  %
  \medskip\hrule\medskip
  %
  \Run $\langle P^{(g)}(\pi^{(k)}), C_1(\rho) \rangle$ \\
  \IndI $(\Gamma_V^{(g)}, \Gamma_H^{(k)}) := \langle P(\pi^{(k)}), C_1(\rho) \rangle_{P^{(g)}}$ \\
  \IndI $x := \langle P^{(g)}(\pi^{(k)}), C_1(\rho) \rangle_{\text{trans}}$ \\ \\
  %
  $(q,y^{(k)}) := \widetilde{C}_2^{\Gamma_V^{(g)}, \Gamma_H^{(k)}, C, hash}(x, \rho)$\\
  %
  \For $i:=1$ to $k$ \Do \IndII //simulate $k$ rounds of sequential interaction \\
  \IndI $(\Gamma_V^{i}, \Gamma_H^{i}) := \langle P^{(1)}(\pi_i), C_1(\rho) \rangle_{P^{(1)}} $\\
  \For $i:=1$ to $k$ \Do \\
  \IndI $c_i := \Gamma_v^{i}(q, y_i)$\\
  \return $(c_1, \dots, c_k)$
\end{codeblock}
%
The procedure \textbf{EstimateSurplus} returns the estimate $\widetilde{S}_{\pi^*, b}$ for $S_{\pi^*, b}$.
All puzzles used during obtaining the estimate are generated internally.
Therefore, it is possible to answer all hint and verification queries, without calls to the verification oracles.
%
\begin{codeblock}
  $\textbf{EstimateSurplus}^{P^{(1)}, C, hash}(\pi^*, b)$
  \medskip
  \hrule
  \medskip
  \textbf{Oracle:} An algorithm $P^{(1)}$, a circuit $C$, a function $hash$, a function $g$.\\
  \textbf{Input:} A bistring $\pi^*$, a bit $b$, an integer $k$.\\
  \textbf{Output:} A circuit $D$.
  \medskip\hrule\medskip
  $\widetilde{g}_b := \textbf{EvaluteFunctionProbability}^{g}(b, \epsilon, \delta)$ \\
  \textbf{For} $i:=1$ to $\frac{16k^2}{\epsilon^2}\log(n)$ \Do \\
  \IndI $(\pi_{m+1}, \dots, \pi_k) \xleftarrow{\$} \{0,1\}^{(k-m-1)n}$\\
  \IndI $\rho \xleftarrow{\$} \{0,1\}^{*}$\\
  \IndI $(c_1, \dots, c_k) := \textbf{EvalutePuzzles}^{P^{(1)}, C, hash}(\pi_1, \dots, \pi_{m}, \pi^*, \dots, \pi_k, \rho)$\\
  \IndI $\widetilde{s}_{\pi^*,b}^i := g(b, c_{m+1}, \dots, c_k)$\\
  \textbf{return} $\frac{\epsilon^2\log(n)}{16k^2} \sum_{i=1}^{\frac{16k^2}{\epsilon^2}\log(n)} \widetilde{s}_{\pi^*,b}^i - \widetilde{g}_b$\\
\end{codeblock}
%
\begin{codeblock}
  \textbf{Circuit $D = (D_1, D_2) (\sigma)$}
  \medskip \hrule \medskip
  \textbf{Phase I $D_1^{P^{(1)}, C}(\sigma)$}
  \medskip \hrule \medskip
  \textbf{Oracle:} A circuit $C$.\\
  \textbf{Input:} A bitstring $\sigma \in \{0,1\}^{*}$.
%  \textbf{Hard coded:} Bitstrings $\pi_1, \dots, \pi_{m-1}$. \\
%  \textbf{Output}:
  \medskip\hrule\medskip

  Interact with the problem poser using $C_1(\rho)$. \\
  \IndI Let $x^*$ be the transcript of the simulations and the interaction with the problem poser.\\
  \IndI Let $\Gamma_V^*, \Gamma_H^*$ be the verification and hint circuits output by the problem poser.

  \medskip \hrule \medskip
  \textbf{Phase II $D_2^{P^{(1)}, C}(x^*, \sigma)$}
  \medskip \hrule \medskip
  \textbf{Oracle:} $P^{(1)}$, $C$, $hash$, $g$, $\Gamma_V^{*}$, $\Gamma_H^{*}$. \\
  \textbf{Input:} A transcript $x^*$, a bitstring $\sigma \in \{0,1\}^{*}$.\\
  \textbf{Output}: A verification query $(q, y*)$.
  \medskip \hrule \medskip
  \For at most $\frac{6k}{\epsilon} \log(\frac{6k}{\epsilon})$ iterations \Do \\
  \IndI $\pi^{(k-1)} \leftarrow$ read $(k-1)\cdot n$ bits from $\sigma$ \\
  \IndI \For $i:=2$ to $k$ \Do \\
  \IndII Simulate $\langle P^{(1)}(\pi_i), C_1(\rho)\rangle$ \\
  \IndIII $ x_i := \langle P^{(1)}(\pi_i), C_1(\rho)\rangle_{\text{trans}}$ \\
  \IndIII $(\Gamma_V^{i}, \Gamma_H^{i}) := \langle P^{(1)}(\pi_i), C_1(\rho) \rangle_{P^{(1)}}$ \\
  \IndI $\Gamma_V^{(g)} := g(\Gamma_V^{*}, \Gamma_V^{2}, \dots, \Gamma_V^{k})$  \\
  \IndI  $\Gamma_H^{(k)} := (\Gamma_H^{*}, \Gamma_H^{2}, \dots, \Gamma_H^{k})$ \\
  \IndI $(q, y^*, y_2, \dots, y_k) := \widetilde{C}^{\Gamma_V^{(g)}, \Gamma_H^{(k)}, C, hash}((x^*, x_2, \dots, x_k), \rho)$\\
  \IndI $(c^*, c_2, \dots, c_k) := (\Gamma_V^*(q, y^*), \Gamma_V^2(q, y_2), \dots, \Gamma_V^{k}(q, y_k))$ \\
  \IndI \If $g(1, c_{2}, \dots, c_k) = 1 \land g(0,c_{2}, \dots, c_k) = 0$ \then \\
  \IndII Make a verification query $(q, y^*)$ \\
  \IndII \return $(q, y^*)$ \\
  \return $\bot$
%
\end{codeblock}
%
\begin{codeblock}
  \textbf{Algorithm $Gen^{C,P^{(1)},g,hash}(\epsilon, \delta, n, v, h, k)$}
  \medskip
  \hrule
  \medskip
  \textbf{Oracle:} $ P^{(1)}, C, g, hash$ \\
  \textbf{Input:}  $\epsilon, \delta, n, v, h, k$\\
  \textbf{Output:} $D$
  \medskip\hrule\medskip
  \For $i:=1$ to $\frac{6k}{\epsilon}\log(n)$ \Do \\
  \IndI $\pi^* \xleftarrow{\$} \{0,1\}^{n}$\\
  \IndI $\widetilde{S}_{\pi^*,0} := \textbf{EstimateSurplus}^{P^{(1)}, C, hash}(\pi^*, 0)$\\
  \IndI $\widetilde{S}_{\pi^*,1} := \textbf{EstimateSurplus}^{P^{(1)}, C, hash}(\pi^*, 1)$\\
  \IndI \If $ \exists b \in \{0,1\}: \widetilde{S}_{\pi^*,b} \geq (1 - \frac{3}{4k}) \epsilon$ \then \\
  \IndII Let $C_1'$ simulate first round of interaction between $C_1$ and $P^{(g)}$ using $P^{(1)}(\pi^*)$, \\
  \IndII then use $C_1$ for remaining $k-1$ rounds. \\
  \IndII Let $C_2'$ be $C_2$ with the solution for the first puzzle discarded. \\
  \IndII $C' := (C_1', C_2')$ \\
  \IndII $g'(b_2, \dots, b_k) := g(b, b_2, \dots, b_k)$\\
  \IndII\return $Gen^{C', P^{(1)}, g', hash}(\epsilon, \delta, n, v, h, k-1)$ \\
  // all estimates are lower than $(1-\frac{3}{4k})\varepsilon$\\
  \return $D^{C}$
\end{codeblock}
%
% The algorithm $Gen$ recursively builds the circuit that have high success probability in solving a dynamic weakly verifiable puzzle.
% When algorithm recurses it fixes a puzzle on the first position on the input of circuit $\widetilde{C}$ which yields a new circuit $\widetilde{C}'$.
% It happens only in the situation when for some fixed $\pi^*$ circuit $\widetilde{C}$ performs good on the remaining $k-1$ puzzles.
%
For $k=1$ the function $g: \{0,1\} \rightarrow \{0,1\}$ is either the identity or a constant function.
If $g$ is the identity function then the success probability of $C$ in the random experiment $CanonicalSuccess$ is as least $\delta + \epsilon$,
and $D$ simply uses the circuit $\widetilde{C}$. In case $g$ is a constant function the statement is vacuously true.

For fixed $\pi^{(k)}, \rho$ let $(\Gamma_V^{(g)}, \Gamma_H^{(k)}) := \langle P^{(g)}(\pi^{(k)}), C_1(\rho) \rangle_{P^{(g)}}$
and $x := \langle P^{(g)}(\pi^{(k)}), C_1(\rho) \rangle_{\text{trans}}$.
Additionally, let $(\Gamma_V^{i}, \Gamma_H^{i})$ be the verification and hint circuits generated in the $i$-th
round of the interaction between $P^{(g)}(\pi^{(k)})$ and $C_1(\rho)$.
Finally, for $(q,y_1, \dots, y_k) := \widetilde{C}_2(x^{(k)}, \rho)$ we denote $c_i := \Gamma_V^i(q,y_i)$.
We define the surplus:
\begin{align}
  \label{eq:s_pi_b}
S_{\pi^*, b} = \underset{\pi^{(k)}, \rho}{\Pr}\left[g(b, c_2, \dots, c_k) = 1\right] - \underset{(u_2, \dots, u_k) \leftarrow \mu^{(k)}}{\Pr}\left[g(b, u_2, \dots, u_k) = 1\right]
\end{align}
%
The surplus $S_{\pi^*, b}$ tells us how good $\widetilde{C}$ performs when the bitstring $\pi_1$ is fixed to $\pi^*$,
and the fact whether $\widetilde{C}$ succeeds in solving the first puzzle defined by $P^{(1)}(\pi_1)$ is disregarded.
Instead, the bit $b$ is used as the input on the first position of the function $g$.

%
\begin{lemma}
  \label{lemma:surplus_estimate}
The estimate $\widetilde{S}_{\pi^*,b}$ returned by \textbf{EstimateSurplus} differs from $S_{\pi^*, b}$ by at most $\frac{\epsilon}{2k}$ almost surely.
\end{lemma}

\begin{proof}
We use union bound and similar argument as in Lemma \ref{lemma:estimate_of_g}
which yields that $\frac{\epsilon^2\log(n)}{16k^2} \sum_{i=1}^{\frac{16k^2}{\epsilon^2}\log(n)} \widetilde{s}_{\pi^*,b}^i$ differs from
$\mathbb{E}[g(b, c_2, \dots, c_k)]$ by at most $\frac{\epsilon}{4k}$ almost surely. Together, with Lemma $\ref{lemma:estimate_of_g}$ we conclude that the surplus estimate
returned by \textbf{EstimateSurplus} differs from $S_{\pi^*,b}$ by at most $\frac{\epsilon}{2k}$ almost surely.
\end{proof}
%
From Lemma \ref{lemma:surplus_estimate} we conclude that if $\widetilde{S}_{\pi^*,b} \geq (1-\frac{3}{4k})\epsilon$, then $S_{\pi^*,b} \geq (1-\frac{1}{k})\epsilon$ almost surely.

In case $Gen$ manages to find an estimate that satisfies $\widetilde{S}_{\pi^*,b} \geq (1-\frac{3}{4k})\epsilon$
we define a monotone function $g'(b_2, \dots, b_k) := g(b, b_2, \dots, b_k)$,
and a circuit $\widetilde{C}' = (C_1', \widetilde{C}_2')$, where
$C_1'$ first simulates the interaction between $C_1$ and $P^{(1)}(\pi^*)$, and then interacts with $P^{(1)}$.

The circuit $\widetilde{C}$ satisfies the conditions of Lemma \ref{lemma:sec_amp_for_p_hash} for
the remaining $k-1$ puzzles and we recurse using $g'$ and $\widetilde{C}'$.

If all estimates are less than $(1-\frac{3}{4k})\epsilon$, then intuitively $C$
does not perform much better on the remaining $k-1$ puzzles than an algorithm that solves each puzzle independent with probability $\delta$.
However, from the assumption we know that on all $k$ puzzles $\widetilde{C}$ has higher success probability.
Therefore, it is likely that the first puzzle is correctly solved with the probability higher than $\delta$.
%
We now show that this intuition is indeed correct. For a fixed $\pi^*$ using (\ref{eq:s_pi_b}), we get
\begin{align}
\label{eq:diff_s01}
  &\underset{u \leftarrow \mu_{\delta}^k}{\Pr}[g(1, u_2, \dots, u_k)=1] - \underset{u \leftarrow \mu_{\delta}^k}{\Pr}[g(0, u_2, \dots, u_k)=1] = \notag\\
&\IndI  \underset{\pi^{(k)}, \rho}{\Pr}[g(1, c_2, \dots, c_k) =1 \mid \pi_1 = \pi^*] - \underset{\pi^{(k)}, \rho}{\Pr}[g(0, c_2, \dots, c_k) = 1 \mid \pi_1 = \pi^*] - (S_{\pi^*,1} - S_{\pi^*,0}).
\end{align}
% \begin{todo}
%   \textbf{TODO:} Better explain why we can write $\Pr(g() = 1 \land g() = 0)$ as the equivalence for the difference.
% \end{todo}
From the monotonicity of $g$ we know that for any set of tuples $(b_1, \dots, b_k)$
and sets $\cB_0 = \{ (b_1, b_2, \dots, b_k): g(0, b_2, \dots, b_k) = 1\}$, $ \cB_1 = \{(b_1, b_2, \dots, b_k) : g(1, b_2, \dots, b_k) = 1 \}$
we have $\cB_0 \subseteq \cB_1$. Hence, we can write (\ref{eq:diff_s01}):
\begin{align}
  \label{eq:diff_s01_next}
  &\underset{u \leftarrow \mu_{\delta}^k}{\Pr}[g(1, u_2, \dots, u_k) = 1 \land g(0, u_2, \dots, u_k) = 0] = \notag\\
&\IndI  \underset{\pi^{(k)}, \rho}{\Pr}[g(1, c_2, \dots, c_k) = 1 \land g(0, c_2, \dots, c_k) = 0 \mid \pi_1 = \pi^*] - (S_{\pi^*,1} - S_{\pi^*,0}).
\end{align}
Let $G_{u^{(k)}}$ denote the event $g(1, u_2, \dots, u_k) = 1 \land g(0, u_2, \dots, u_k) = 0$, and correspondingly
$G_{\pi^{(k)}} := g(1, c_2, \dots, c_k) = 1) \land (g(0, c_2, \dots, c_k) = 0$.
From (\ref{eq:diff_s01_next}) for $\pi = \pi^*$ fixed we obtain
\begin{align}
\label{eq:pr_d_succ_0}
  \underset{\substack{\rho \\ \prGx}}{\Pr}[\Gamma_V(D_2(x^*, \rho)) = 1] &=
  \frac{\underset{\rho}{\Pr}[\Gamma_V(D_2(x^*, \rho)) = 1 \mid \pi_1 = \pi^*] \underset{\rho}{\Pr}[G_{\pi} \mid \pi_1 = \pi^*]} {\underset{u \leftarrow \mu_{\delta}^{k}}{\Pr}[G_{\mu}]} \notag\\
  & \IndI - \frac{\underset{\rho}{\Pr}[\Gamma_V(D_2(x^*, r)) = 1 \mid \pi_1 = \pi^*](S_{\pi^*,1} - S_{\pi^*,0})}{\underset{u \leftarrow \mu_{\delta}^{k}}{\Pr}[G_{\mu}]}
\end{align}
%
% \begin{todo}
%   \textbf{TODO:} Define $c_1, \dots, c_k$ correctly from the paper it is not known whether it is in the iteration or the final one
% \end{todo}
%If $D_2(x^*,\rho) \neq \bot$ then we denote $c_i := \Gamma_V^{i}(q, y_i)$.
We can write the first summand of (\ref{eq:pr_d_succ_0}) as
\begin{align}
  &\underset{\rho}{\Pr}[\Gamma_V(D_2(x^*,\rho)) = 1 \mid \pi_1 = \pi^*] \underset{\pi^{(k)}}{\Pr}[G_{\pi} \mid \pi_1 = \pi^*] = \notag\\
  &\IndI \underset{\rho}{\Pr}[D_2(x^*,\rho) \neq \bot \mid \pi_1 = \pi^*]
  \underset{\pi^{(k)}}{\Pr}[c_1 = 1 \mid G_{\pi}, \pi_1 = \pi^*]
  \underset{\pi^{(k)}}{\Pr}[G_{\pi} \mid \pi_1 = \pi^*]
\end{align}
where we make use of the fact that the event $G_{\pi}$ implies $D(x^*, r) \neq \bot$.
We consider two cases.
For $\underset{\pi^{k}}{\Pr}[g(1, c_2, \dots, c_k) = 1 \land g(0, c_2, \dots,c_k ) = 0 \mid \pi_1 = \pi^*] \leq \frac{\epsilon}{6k}$ then
\begin{align}
  \underset{\pi^{(k)}}{\Pr}[c_1 = 1 \mid G_{\pi}, \pi_1 = \pi^*] \underset{\pi^{(k)}}{\Pr}[G_{\pi} \mid \pi_1 = \pi^*] \leq \frac{\epsilon}{6k},
\end{align}
and when $\underset{\pi^{k}}{\Pr}[g(1, c_2, \dots, c_k) = 1 \land g(0, c_2, \dots,c_k ) = 0] > \frac{\epsilon}{6k}$ then circuit $D$ outputs $\bot$
only if it fails in all $\frac{6k}{\epsilon} \log(\frac{6k}{\epsilon})$ iterations to find $\pi^{(k)}$ such that $g(1, c_2, \dots, c_k) = 1 \land g(0, c_2, \dots, c_k) = 0$
which happens with probability
\begin{align}
\underset{r}{\Pr}[D(x^*,r) = \bot \mid \pi_1 = \pi^*] \leq (1 - \frac{\epsilon}{6k})^{\frac{6k}{\epsilon}\log(\frac{\epsilon}{6k})} \leq \frac{\epsilon}{6k}.
\end{align}
We conclude that in both cases:
\begin{align}
  &\underset{r}{\Pr}[D(x^*,r) \neq \bot \mid \pi_1 = \pi^*]
  \underset{\pi^{(k)}}{\Pr}[c_1 = 1 \mid G_{\pi}, \pi_1 = \pi^*]
  \underset{\pi^{(k)}}{\Pr}[G_{\pi} \mid \pi_1 = \pi^*] \notag\\
  &\IndII \geq \underset{\pi^{(k)}}{\Pr}[c_1 = 1 \mid G_{\pi}, \pi_1 = \pi^*]\underset{\pi^{(k)}}{\Pr}[G_{\pi} \mid \pi_1 = \pi^*] - \frac{\epsilon}{6k}.
\end{align}
Therefore, we have
\begin{align*}
  &\underset{r}{\Pr}[D(x^*,r) \neq \bot \mid \pi_1 = \pi^*]
  \underset{\pi^{(k)}}{\Pr}[c_1 = 1 \mid G_{\pi}, \pi_1 = \pi^*]
  \underset{\pi^{(k)}}{\Pr}[G_{\pi} \mid \pi_1 = \pi^*] \notag\\
  &\IndII = \underset{\pi^{(k)}}{\Pr}[c_1 = 1 \land g(1, c_2,\dots, c_k) = 1 \land g(0, c_2, \dots, c_k) = 0 \mid \pi_1 = \pi^*] - \frac{\epsilon}{6k} \\
  &\IndII = \underset{\pi^{(k)}}{\Pr}[g(c_1, c_2,\dots, c_k) = 1 \land g(0, c_2, \dots, c_k) = 0 \mid \pi_1 = \pi^*] - \frac{\epsilon}{6k} \\
  &\IndII = \underset{\pi^{(k)}}{\Pr}[g(c_1, c_2,\dots, c_k) = 1 \mid \pi_1 = \pi^*] -  \underset{\pi^{(k)}}{\Pr}[g(0, c_2, \dots, c_k) = 0 \mid \pi_1 = \pi^*] - \frac{\epsilon}{6k},
\end{align*}
and finally by (\ref{eq:s_pi_b})
\begin{align}
  &\underset{r}{\Pr}[D(x^*,r) \neq \bot \mid \pi_1 = \pi^*]
  \underset{\pi^{(k)}}{\Pr}[c_1 = 1 \mid G_{\pi}, \pi_1 = \pi^*]
  \underset{\pi^{(k)}}{\Pr}[G_{\pi} \mid \pi_1 = \pi^*] \notag\\
  &\IndII = \underset{\pi^{(k)}}{\Pr}[g(c_1, c_2,\dots, c_k) = 1 \mid \pi_1 = \pi^*] -  \underset{\mu_{\delta}^{(k)}}{\Pr}[g(0, \mu_2, \dots, \mu_k) = 0 \mid \pi_1 = \pi^*]  - S_{\pi^*,0} - \frac{\epsilon}{6k}.
\end{align}
Inserting this result into the equation (\ref{eq:pr_d_succ_0}) yields
\begin{align}
\label{eq:pr_d_succ_1}
  &\underset{r,\pi}{\Pr}[\Gamma_V(D(x,r)) = 1] = \mathbb{E_{\pi}}\left[\underset{r}{\Pr}[D(x,r) = 1 \mid \pi_1 = \pi^*]\right] \notag\\
&\IndI = \mathbb{E}_{\pi}\left[\frac{{\Pr}_{\pi^{(k)}}[g(c) = 1 \mid \pi_1 = \pi^*] -
{\Pr}_{\mu_{\delta}^{(k)}}[g(0, \mu_2, \dots, \mu_k) = 0 \mid \pi_1 = \pi^*] - \frac{\epsilon}{6k}} {{\Pr}_{\mu_{\delta}^{k}}[G_{\mu}]}\right] \notag\\
&\IndII - \mathbb{E}_{\pi}\left[\frac{
  S_{\pi^*,0} + \Pr_r [\Gamma_V^{(g)}(D(x^*,r)) = 1 \mid \pi_1 = \pi^*](S_{\pi^*,1} - S_{\pi^*,0})}
{{\Pr}_{\mu_{\delta}^{k}}[G_{\mu}]}\right]
\end{align}
For the second summand we show that if we do not recurse, then almost surely majority of estimates is low.
Let assume
\begin{align}
\underset{\pi}{\Pr}\left[\left(S_{\pi,0} \leq (1 - \frac{1}{2k})\epsilon\right) \land \left( S_{\pi,1} \leq (1-\frac{1}{2k})\epsilon\right)\right] < 1 - \frac{\epsilon}{6k},
\end{align}
then the algorithm recurses almost surely.
Therefore, under the assumption that $Gen$ does not recurse, we have almost surely
\begin{align}
\underset{\pi}{\Pr}\left[\left(S_{\pi,0} \leq (1 - \frac{1}{2k})\epsilon\right) \land \left( S_{\pi,1} \leq (1-\frac{1}{2k})\epsilon\right)\right] \geq 1 - \frac{\epsilon}{6k}.
\end{align}
Let us define a set
\begin{align}
  \cW = \left\{ \pi :  \left(S_{\pi,0} \leq (1 - \frac{1}{2k})\epsilon\right) \land \left( S_{\pi,1} \leq (1-\frac{1}{2k})\epsilon \right) \right\}
\end{align}
and use $\cW^c$ to denote the complement of $\cW$.
We bound the second summand in (\ref{eq:pr_d_succ_1})
\begin{align}
&\mathbb{E}_{\pi}\left[ S_{\pi^*,0} + \Pr_r [\Gamma_V^{(g)}(D(x^*,r)) = 1 \mid \pi_1 = \pi^*](S_{\pi^*,1} - S_{\pi^*,0}) \right] \notag\\
&\IndII = \mathbb{E}_{\pi \in \cW^c}\left[ S_{\pi^*,0} + \Pr_r [\Gamma_V^{(g)}(D(x^*,r)) = 1 \mid \pi = \pi^*](S_{\pi^*,1} - S_{\pi^*,0}) \right] \notag\\
&\IndIII +  \mathbb{E}_{\pi \in \cW}\left[ S_{\pi^*,0} + \Pr_r [\Gamma_V^{(g)}(D(x^*,r)) = 1 \mid \pi = \pi^*](S_{\pi^*,1} - S_{\pi^*,0}) \right] \\
&\IndII \leq \frac{\epsilon}{6k} + \mathbb{E}_{\pi \in \cW^c}\left[ S_{\pi^*,0} + \Pr_r [\Gamma_V^{(g)}(D(x^*,r)) = 1 \mid \pi = \pi^*]((1 - \frac{1}{2k})\epsilon - S_{\pi^*,0}) \right] \\
&\IndII \leq \frac{\epsilon}{6k} + 1 - \frac{\epsilon}{2k} = 1 - \frac{\epsilon}{3k}
\end{align}
Finally, we insert this result into equation (\ref{eq:pr_d_succ_1}) and make use of the fact
\begin{align*}
\underset{}{\Pr}[g(u) = 1] &= \underset{}{\Pr}[(g(0, \mu_2, \dots, \mu_k) = 1) \lor ( g(1,\mu_2, \dots, \mu_k) = 1 \land g(0, \mu_2, \dots, \mu_k) = 0 \land \mu_1 = 1)] \notag\\
&= \Pr[g(0,\mu_2, \dots,\mu_k) = 1] + \Pr[g(1,\mu_2,\dots,\mu_k) = 1 \land g(0, \mu_2, \dots, \mu_k) = 0] \Pr[\mu_1 = 1]
\end{align*}
which yields
\begin{align*}
  \underset{r,\pi}{\Pr}[D(x,r) = 1]
&\geq \mathbb{E}_{\pi}\left[\frac{{\Pr}_{\pi^{(k)}}[g(c) = 1 \mid \pi_1 = \pi^*] -
{\Pr}_{\mu_{\delta}^{(k)}}[g(0, \mu_2, \dots, \mu_k) = 0] - (1 - \frac{1}{6k})\epsilon} {{\Pr}_{\mu_{\delta}^{k}}[G_{\mu}]}\right] \notag
 \end{align*}
 Using the assumptions of Lemma \ref{lemma:sec_amp_for_p_hash}, we get
 \begin{align}
   \label{eq:proof_final}
   \underset{r,\pi}{\Pr}[\Gamma_V(D(x,r)) = 1]
 &\geq \frac{ {\Pr}_{\mu_{\delta}^{(k)}}[g(\mu) = 1] + \epsilon +
 \Pr_{\mu_{\delta}^{(k)}}[g(0, \mu_2, \dots, \mu_k) = 0] - (1 - \frac{1}{6k})\epsilon}
 {\Pr_{\mu_{\delta}^{k}}[G_{\mu}]} \notag\\
 &\geq \frac{\epsilon +
\delta\Pr_{\mu_{\delta}^{(k)}}[G_{\mu}] - (1 - \frac{1}{6k})\epsilon}
{\Pr_{\mu_{\delta}^{k}}[G_{\mu}]} \geq \delta + \frac{\epsilon}{6k}
\end{align}
% Finally, by Lemma \ref{lemma:ctilda_c} and (\ref{eq:proof_final}) we get,
% \begin{align*}
%    \underset{\rho,\pi}{\Pr}[\Gamma_V(D(x,r)) = 1] \leq  \delta + \frac{\epsilon}{6k}
% \end{align*}
\end{proof}
Now, we can show that the Theorem \ref{def:dwvp} follows by Lemma \ref{lemma:hash_function_probability} and Lemma \ref{lemma:sec_amp_for_p_hash}.
First we define the following circuit:
\begin{codeblock}
  \textbf{E}
  \medskip
  \hrule
  \medskip
  \textbf{Oracle:} Circuit $D$ from Lemma \ref{lemma:sec_amp_for_p_hash}  \\
  \textbf{Input:} A bitstring $\rho \in \{0,1\}^{*}$
  \medskip\hrule\medskip
  Run circuit $(q,y) = D(\rho)$ \\
  \If $(q,y) \neq \bot$ \then \\
  \IndI make a verification query $(q,y)$
\end{codeblock}
%
The circuit $E$ is output by the following algorithm $Gen$.
\begin{codeblock}
  \textbf{Gen}
  \medskip
  \hrule
  \medskip
  \textbf{Oracle:}  $C, P^{(1)}, g$\\
  \textbf{Input:} $\epsilon, \delta, n, h, v$
  \medskip\hrule\medskip
  Let $\cH$ be a set of pairwise independent hash functions $Q \rightarrow \{0, 1, \dots, 2(h+v)-1\}$ \\
  $hash := \textbf{FindHash}(\cH,h+v)$ \\
  $D := Gen(C, g, \epsilon, \delta, n, h, v, hash)$ \\
  \return $D^{P^{1}, C, hash}(\rho)$
\end{codeblock}
From the assumptions of Theorem \ref{th:sec_amp_for_dwvp} we know that success probability of $C$ is at least
\begin{align*}
8(h+v)\left(\underset{u \leftarrow \mu_\delta^k}{\Pr}\left[g(u) = 1\right] + \varepsilon\right),
\end{align*}
then by Lemma \ref{lemma:hash_function_probability}, the canonical success
probability of $\widetilde{C}$ with respect to function $hash$ is at least
\begin{align*}
\left(\underset{u \leftarrow \mu_\delta^k}{\Pr}\left[g(u) = 1\right] + \varepsilon\right).
\end{align*}
Then we apply Lemma \ref{lemma:sec_amp_for_p_hash} with respect to $\widetilde{C}$ and $hash$ which yields a circuit $D$ that
outputs $(q, y)$ such that
\begin{align*}
    \underset{\substack{\pi, \sigma \\ (\Gamma_V,\Gamma_H) := \langle P^{(1)}(\pi), D(\rho) \rangle_{P^{(1)}} \\ x := \langle P^{(1)}(\pi), D(\rho) \rangle_{\text{trans}}}}
    {\Pr}\left[\Gamma_V(D^{P^{(1)},C,\Gamma_V, \Gamma_H, hash}(x, \sigma)) = 1\right] \geq (\delta + \frac{\varepsilon}{6k}).
\end{align*}
Hence, the probability that the verification query made by $E$ is successful is at least $(\delta + \frac{\varepsilon}{6k})$.
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../master"
%%% End:
