\begin{definition} {\textbf{Dynamic weakly verifiable puzzle}}\\
  A dynamic weakly verifiable puzzle (DWVP) is defined by a protocol between probabilistic algorithms $P(\pi)$ and $S(\rho)$.
  The algorithm $P$, called a problem poser, takes as input chosen uniformly at random bitstring $\pi$.
  The problem solver $S$ takes as input a uniform random bitstring $\rho$.
  As the result of the protocol execution between $P$ and $S$,
  $P$ produces circuits $\Gamma_{V}$, $\Gamma_{H}$ and a puzzle $x \in \{0,1\}^{*}$, $S$ produces no output.
  The circuit $\Gamma_{V}$ takes as input $q \in Q$ and an answer $y \in \{0,1\}^*$.
  If $\Gamma_V(q,y) = 1$ then $y$ is a correct solution of a puzzle $x$ for $q$.
  The circuit $\Gamma_H$ on input $q$ provides a hint such that $\Gamma_V(q,\Gamma_H(q)) = 1$.
  The solver $S$ receives a puzzle $x$, and has oracle access to $\Gamma_V$ and $\Gamma_H$.
  The calls of $S$ to $\Gamma_V$ are verification queries and to $\Gamma_H$ are hint queries.
  The solver $S$ can ask at most $h$ hint queries, $v$ verification queries, and successfully solves DWVP if and only if
  it makes a verification query $(q,y)$ such that $\Gamma_V(q,y) = 1$, when it has not previously asked for a hint query on this $q$.
\end{definition}
%
\begin{todo}
  \textbf{TODO:} Requirements on g (we calculate $\Pr(g(b_1, \dots, b_k) = 1)$).
\end{todo}
%
\begin{definition}{\textbf{$k$-wise direct product of dynamic weakly verifiable puzzles}}\\
Let $g: \{0,1\}^{k} \rightarrow \{0,1\}$ be a monotone function and $P^{(1)}$ a problem poser used to generate an instance of DWVP.
A $k$-wise direct product of dynamic weakly verifiable puzzles is defined by a protocol between a probabilistic algorithms $P^{(g)}(\pi^{(k)})$ and
$S(\rho)$, where $\pi^{(k)} := (\pi_1, \dots, \pi_k)$ and every $\pi_i \in \{0,1\}^{l}$ for $1 \leq i \leq k$ and $\rho$ are chosen uniformly at random.
The protocol execution generates sequentially $k$ independent instances of DWVP,
where the $i$-th instance $(x_i, \Gamma_V^{i}, \Gamma_H^{i} )$ is produced by $S(\rho)$ interacting with $P^{(1)}(\pi_i)$.
Finally, $P^{(g)}$ outputs a verification circuit
\begin{align*}
  \Gamma_V^{(g)} (q, y_1, \dots, y_k) := g(\Gamma_V^{1}(q, y_1), \dots, \Gamma_V^{k}(q, y_k)),
\end{align*}
a hint circuit
\begin{align*}
  \Gamma_H^{(k)} (q) := (\Gamma_H^{1}(q), \dots, \Gamma_H^{k}(q)),
\end{align*}
and a puzzle $x^{(k)} := (x_1, \dots, x_k)$.

The solver $S$ receives puzzles $(x_1, \dots, x_k)$, has oracle access to $\Gamma_V^{(g)}, \Gamma_H^{(k)}$, and
can ask at most $v$ verification queries to $\Gamma_V^{(g)}$, $h$ hint queries to $\Gamma_H^{(k)}$, and successfully solves the puzzle $x^{(k)}$
if and only if it asks a verification query $(q, y^{(k)}) := (q, y_1, \dots, y_k)$ such that $\Gamma_V^{(g)}(q, y^{(k)}) = 1$, and has not previously asked for a hint query on this $q$.
\end{definition}
%
\begin{todo}
  \textbf{TODO:} We abuse the notation using, when the protocol is executed $C(\rho)$, and in the second phase when the puzzles are solved $C^{\Gamma_V^{(g)}, \Gamma_H^{(k)}}(x^{(k)}, \rho)$.
\end{todo}
%
\begin{codeblock}
  \textbf{Experiment $A^{P^{(k)}, C^{(\cdot, \cdot)}}(\pi^{(k)}, \rho)$}\\
  Solving a $k$-wise direct product of DWVP
  \medskip
  \hrule
  \medskip
  \textbf{Oracle:} A problem poser $P^{(k)}$, a solver circuit $C^{(\cdot,\cdot)}$.\\
  \textbf{Input:}  Bitstrings $\pi^{(k)}$, $\rho$.
  \medskip\hrule\medskip
  $(x^{(k)}, \Gamma_V^{(g)}, \Gamma_H^{(k)}) := \langle P^{(k)}(\pi^{(k)}), C(\rho) \rangle_{P^{(k)}}$ \\
  Run $C^{\Gamma_V^{(g)},\Gamma_H^{(k)}}(x^{(k)}, \rho)$ \\
  \IndI Let $Q_{Solved} := \{q: \text{$C^{\Gamma_V^{(g)}, \Gamma_H^{(k)}}$ asked a verification query $(q,y^{(k)})$ and $\Gamma_V^{(g)}(q, y^{(k)}) = 1$} \}$\\
  \IndI Let $Q_{Hint} := \{q: \text{$C^{\Gamma_V^{(g)}, \Gamma_H^{(k)}}$ asked a hint query on q} \}$\\
  \textbf{If} $\exists q \in Q_{solved} : q \notin Q_{Hint}$ \then \\
  \IndI \textbf{return} $1$\\
  \textbf{else} \\
  \IndI \textbf{return} $0$\\
\end{codeblock}
%
\begin{theorem}{\textbf{Security amplification for a dynamic weakly verifiable puzzle.}}
\label{th:sec_amp_for_dwvp}\\
For a fixed problem poser $P^{(1)}$ there exists a probabilistic algorithm $Gen(C, g, \varepsilon, \delta, n, v, h)$ which takes as input a solver circuit $C$ for a $k$-wise
direct product of DWVP, a monotone function $g$, parameters $\varepsilon, \delta,n$, the number of verification $v$, and hint $h$ queries asked by $C$, and outputs a circuit $D$
such that following holds: \\
If $C$ is such that \\
  \begin{align*}
    \underset{\pi^{(k)}, \rho }{\Pr}[A^{P^{(g)}, C}(\pi^{(k)}, \rho) = 1]
    \geq 8(h+v) \left(\underset{\mu \leftarrow \mu_\delta^k}{\Pr}[g(\mu) = 1] + \varepsilon\right)
  \end{align*}
then $D$ satisfies almost surely
  \begin{align*}
    \underset{\pi, \rho}{\Pr}[A^{P^{(1)},D}(\pi, \rho) = 1] \geq (\delta + \frac{\varepsilon}{6k})
  \end{align*}
Additionally, $D$ and $Gen$ require only oracle access to $g$ and $C$. Furthermore, $D$ asks at most $h$ hint queries, $v$ verification queries and
$Size(D) \leq Size(C) \cdot \Theta(\frac{6k}{\varepsilon})$ and $Time(Gen) = poly(k, \frac{1}{\varepsilon}, n, v, h)$.
\end{theorem}
%
%
\begin{codeblock}
  \textbf{Experiment $E^{P^{(g)}, C^{(\cdot, \cdot)}, hash}(\pi^{(k)}, \rho)$}
  \medskip

  \hrule

  \medskip
  \textbf{Oracle:} A problem poser $P^{(g)}$ for a $k$-wise direct product. \\
  \IndI A solver circuit $C^{(\cdot, \cdot)}$ for a $k$-wise direct product. \\
  \IndI A function $hash: Q \rightarrow \{0, \dots, 2(h+v) - 1\}$.\\
  \textbf{Input:} Random bitstrings: $\pi^{(k)}$, $\rho$.
  \medskip\hrule\medskip
  $(x^{(k)}, \Gamma_V^{(g)}, \Gamma_H^{(k)}) := \left\langle P^{(g)}(\pi^{(k)}), C(\rho) \right\rangle$\\
  Run $C^{\Gamma_V^{(g)}, \Gamma_H^{(k)}} (x^{(k)}, \rho)$ \\
  \IndI Let $(q_j,y_j^{(k)})$ be the first successful verification query if $C^{\Gamma_V^{(g)}, \Gamma_H^{(k)}}$ succeeds or \\
  \IndI an arbitrary verification query when it fails.\\
  \\
  \textbf{If} $(\forall i < j :  q_i \notin P_{hash} ) \land q_j \in P_{hash} \land \Gamma_V^{(g)}(q_j, y_j^{(k)}) = 1$ \\
  \IndI \textbf{return} 1\\
  \textbf{else}\\
  \IndI \textbf{return} 0
\end{codeblock}
%
\begin{codeblock}
  \textbf{Algorithm: FindHash}
  \medskip
  \hrule
  \medskip

  \textbf{Oracle:} A solver circuit $C^{(\cdot, \cdot)}$ for a $k$-wise direct product of DWVP. \\
  \IndII A problem poser $P^{(g)}$ for a $k$-wise direct product. \\
  \textbf{Input:} A set $\cH$.
  \medskip\hrule\medskip
  For $i = 1$ to $32(h+v)^2/\gamma^2$ \\
  \IndI $hash \xleftarrow{\$} \cH$ \\
  \IndI $count := 0$ \\
  \IndI \For $j := 1$ to $32(h+v)^2/\gamma^2$ \\
  \IndII $\pi^{(k)} \xleftarrow{\$} \{0,1\}^{kl} $\\
  \IndII $\rho \xleftarrow{\$} \{0,1\}^{*} $\\
  \IndII \If $E^{P^{(g)}, C^{(\cdot, \cdot)}, hash}(\pi^{(k)}, \rho) = 1$ \then \\
  \IndIII $count := count + 1$\\
  \IndI \If $\frac{\gamma^2}{32(h+v)^2} count \geq \frac{\gamma}{6(h+v)}$ \\
  \IndII \return $hash$\\
  \return $\bot$
\end{codeblock}
%
%
\begin{codeblock}
  \textbf{Circuit $\widetilde{C}^{\Gamma_V^{(g)}, \Gamma_H^{(g)}, hash, C} (x_1, \dots, x_k)$} \\
  Circuit $\widetilde{C}$ has good canonical success probability.
  \medskip

  \hrule

  \medskip

  \textbf{Oracle:} $\Gamma_V^{(g)}, \Gamma_H^{(k)}, hash, C$ \\
  \textbf{Input:} k-wise direct product of puzzles $(x_1, \dots, x_k)$

  \medskip\hrule\medskip
  Run $C^{(\cdot,\cdot)}(x_1, \dots, x_k, \rho)$ \\
  \IndI \If $C$ asks a hint query $q$ \then\\
  \IndII \If $q \in P_{hash}$ \then\\
  \IndIII \return $\bot$\\
  \IndII \textbf{else}\\
  \IndIII return $\Gamma_H^{(k)}(q)$ to $C$\\
  \\
  \IndI \If $C$ asks a verification query on $(q, y_1, \dots, y_k)$ \then \\
  \IndII \If $q \in P_{hash}$ \textbf{then} \\
  \IndIII \return $(q, y_1, \dots, y_k)$ \\
  \IndII \textbf{else} \\
  \IndIII answer the verification query with 0 \\
  \return $\bot$
\end{codeblock}
%
%
\begin{codeblock}
  \textbf{Algorithm $Gen(C,g,\epsilon,\delta,n, v, h, hash)$}
  \medskip

  \hrule

  \medskip

  \textbf{Oracle:} $C, g$ \\
  \textbf{Input:}  $\epsilon, \delta, n, v, h$\\
  \textbf{Output:} A circuit $D$, $hash$
  %TODO what is canonical success probability with respect to this hash oracle.
  \medskip\hrule\medskip
  \If \text{the number of puzzles to solve equals one} \then \\
  \IndI \return $\widetilde{C}$ \\ \\
  \textbf{For} $i:=1$ to $\frac{6k}{\epsilon}\log(n)$ \\
  \IndI $\pi^* \leftarrow \{0,1\}^{l}$\\
  \IndI $\widetilde{S}_{\pi^*,0} := EvaluateSurplus(\pi^*, 0)$\\
  \IndI $\widetilde{S}_{\pi^*,1} := EvaluateSurplus(\pi^*, 1)$\\
  \IndI \textbf{If} $\widetilde{S}_{\pi^*,0} \geq (1 - \frac{3}{4k}) \epsilon$ or $\widetilde{S}_{\pi^*,1} \geq (1 - \frac{3}{4k}) \epsilon$ \\
  \IndII $\widetilde{C}' := \widetilde{C}$ with the first input fixed on $\pi^*$\\
  \IndII\textbf{return} $Gen(\widetilde{C}', g, \epsilon, \delta, n)$ \\
  // all estimates are lower than $(1-\frac{3}{4k})\varepsilon$\\
  \return $D^{\widetilde{C}}$ \\
  \\
  \textbf{EvaluateSurplus}($\pi^*, b$) \\
  \IndI \textbf{For} $i:=1$ to $N_k$ \\
  \IndII $(\pi_2, \dots, \pi_k) \xleftarrow{\$} \{0,1\}^{(k-1)l}$\\
  \IndII $(c_1, \dots, c_k) := EvalutePuzzles(\pi^*, \pi_2, \dots, \pi_k)$\\
  \IndII $\widetilde{S}_{\pi^*,b}^i := g(b, c_2, \dots, c_k) - \underset{(u_2, \dots, u_k)}{\Pr}[g(b, u_2, \dots, u_k) = 1] $\\
  \IndI \textbf{return} $\frac{1}{N_k} \sum_{i=1}^{N_k} \widetilde{S}_{\pi^*,b}^i$\\
  \\
  \textbf{EvalutePuzzles}($\pi^{(k)}$)\\
  \IndI $(x^{(k)}, \Gamma_V^{(g)}, \Gamma_H^{(k)}) := P^{(g)}(\pi^{(k)})$ \\
  \IndI \textbf{For} $i:=1$ to $k$\\
  \IndII $(x_i, \Gamma_V^{i}, \Gamma_H^{i}) := P^{(1)}(\pi_i)$\\
  \IndI $(q,y^{k}) := \widetilde{C}^{\Gamma_V^{(g)}, \Gamma_H^{(k)}}(x_1, x_2, \dots, x_k)$\\
  \IndI \textbf{For} $i:=1$ to $k$\\
  \IndII $c_i := \Gamma_v^{i}(q, y_i)$\\
  \IndI \textbf{return} $(c_1, \dots, c_k)$\\
\end{codeblock}
%
% \begin{todo}
%   \textbf{TODO:} Circuit $\widetilde{C}$ gets as input puzzle find a nice way to genereate the puzzles as it is used in many places in the code.
%    Also make EvalutePuzzles more general maybe it should take $\widetilde{C}$ as input?
% \end{todo}
\begin{codeblock}
  \textbf{Circuit $D^{\widetilde{C}, P^{(1)}}$}
  \medskip

  \hrule

  \medskip

  \textbf{Oracle:} A circuit $\widetilde{C}$ with the first $n$ puzzles fixed, $P^{(1)}$\\
  \textbf{Input:} A puzzle $x^*$, a random bitstring $r \in \{0,1\}^{*}$

  \medskip\hrule\medskip
  \textbf{For} $i:=1$ to $\frac{6k}{\epsilon} \log(\frac{6k}{\epsilon})$\\
  \IndI $\pi^{(k)} \leftarrow \{0,1\}^{(k-n-1)l}$ //read bits from $r$  \\
  \IndI $(c_1, \dots, c_{k-n-1}) := EvaluatePuzzles(\pi^{(k-n-1)})$\\
  \IndI \textbf{If} $g(1,c_2, \dots, c_k) =1 \land g(0,c_2, \dots, c_k) = 0$\\
  \IndII \textbf{For} $i:=1$ to $k-n-1$\\
  \IndIII $(x_i, \Gamma_V^{i}, \Gamma_H^{i}) := P^{(1)}(\pi_i)$\\
  \IndII $(q, y_1, \dots, y_{k-n-1}) := \widetilde{C}(x^*, x_2, \dots, x_{k-n-1})$\\
  \IndII \textbf{return} $y_1$\\
  \textbf{return} $\bot$ \\

\end{codeblock}
%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "master"
%%% End:
