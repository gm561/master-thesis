%% (Master) Thesis template
% Template version used: v1.4
%
% Largely adapted from Adrian Nievergelt's template for the ADPS
% (lecture notes) project.

%% We use the memoir class because it offers a many easy to use features.
\documentclass[11pt,a4paper,titlepage]{memoir}

%% Packages
%% ========

%% LaTeX Font encoding -- DO NOT CHANGE
\usepackage[OT1]{fontenc}

%% Babel provides support for languages.  'english' uses British
%% English hyphenation and text snippets like "Figure" and
%% "Theorem". Use the option 'ngerman' if your document is in German.
%% Use 'american' for American English.  Note that if you change this,
%% the next LaTeX run may show spurious errors.  Simply run it again.
%% If they persist, remove the .aux file and try again.
\usepackage[english]{babel}

%% Input encoding 'utf8'. In some cases you might need 'utf8x' for
%% extra symbols. Not all editors, especially on Windows, are UTF-8
%% capable, so you may want to use 'latin1' instead.
\usepackage[utf8]{inputenc}

%% This changes default fonts for both text and math mode to use Herman Zapfs
%% excellent Palatino font.  Do not change this.
%\usepackage[sc]{mathpazo}

%% The AMS-LaTeX extensions for mathematical typesetting.  Do not
%% remove.
\usepackage{amsmath,amssymb,amsfonts,mathrsfs}

%% NTheorem is a reimplementation of the AMS Theorem package. This
%% will allow us to typeset theorems like examples, proofs and
%% similar.  Do not remove.
%% NOTE: Must be loaded AFTER amsmath, or the \qed placement will
%% break
\usepackage[amsmath,thmmarks]{ntheorem}

%% LaTeX' own graphics handling
\usepackage{graphicx}

%% We unfortunately need this for the Rules chapter.  Remove it
%% afterwards; or at least NEVER use its underlining features.
\usepackage{soul}

%% Some more packages that you may want to use.  Have a look at the
%% file, and consult the package docs for each.
\input{extrapackages}

%% Our layout configuration.  DO NOT CHANGE.
\input{layoutsetup}

%% Theorem environments.  You will have to adapt this for a German
%% thesis.
\input{theoremsetup}

%% Helpful macros.
\input{macrosetup}

%% Make document internal hyperlinks wherever possible. (TOC, references)
%% This MUST be loaded after varioref, which is loaded in 'extrapackages'
%% above.  We just load it last to be safe.
\usepackage[linkcolor=black,colorlinks=true,citecolor=black,filecolor=black]{hyperref}

\allowdisplaybreaks[1]

%% Document information
%% ====================

\title{On amplification of weakly verifiable dynamic cryptographic primitives}
\author{Grzegorz Makosa}
\thesistype{Master Thesis}
\advisors{Advisors: Prof. Dr. Thomas Holenstein, Dr. Robin KÃ¼nzler}
\department{Department of Computer Science}
\date{April 8, 2014}

\begin{document}

\frontmatter

% \begin{titlingpage}
%   \calccentering{\unitlength}
%   \begin{adjustwidth*}{\unitlength-24pt}{-\unitlength-24pt}
%     \maketitle
%   \end{adjustwidth*}
% \end{titlingpage}
%\input{abstract}

\cleartorecto
\tableofcontents
\mainmatter

\chapter{Introduction}
\section{Hardness Amplification Theorems}
Cryptography is science where very little is known about computational hardness of the fundamental problems.
Furthermore, showing computational hardness of these problems often leads to proving that $P \neq NP$ or showing the existence of one-way functions.
However, certain problems seem to be more likely to be hard than others.
Thus, we often study computational hardness of a problem $Q$ under the assumption that a problem $P$ is computationally hard.

We want the assumptions on which cryptography is based be as weak as possible.
Therefore, an important and often studied question is whether it is possible to turn a problem $P$
that is only mildly hard into a problem $Q$ that solving is much harder.
The statements of this types are called hardness amplification. One of the most well known
results is by Yao who proved that it is indeed possible to build a strongly secure one--way function
from a one--way function that is only weakly secure.

In this Thesis we study a question whether it is possible to achieve a similar result also for basic cryptographic constructions
like signature schemes, message authentication codes, or bit commitment protocols, just to name a few.
We define a \textit{weakly verifiable puzzle} that generalize many commonly encountered cryptographic primitives.
The characteristic property of weakly verifiable puzzles is that one do not require that verifying the correctness of a solution by solver is efficient\footnote{
The word \textit{weakly} in the context of weakly verifiable puzzles is used in a different meaning than for a weak one--way function.
It refers to lack of inefficient solver algorithms for verifying the correctness of solution.}.
An example is CAPTCHA where a problem of checking whether a solution is correct by a solver is comparably hard to finding a correct solution.
On the other hand, the problem poser has access to some secret information such that verifying correctness of the solution is easy.

There are two general approaches to amplify hardness. Both base on solving a several weakly hard problems which should yield a construction that is strongly hard.
First, one can try to use sequential repetition where a protocol is repeated in rounds that start one after another.
It has been observed that sequential repetition amplifies hardness of weakly verifiable puzzles by \cite{von2003captcha}.
However, this approach may be inefficient as it increases the number of rounds creating additional communication burden.

The more useful approach both from the practical and theoretical point of view is the hardness amplification by means of the
parallel repetition. However, it has been shown that parallel repetition does not always amplify hardness \cite{bellare1997does}.
Therefore, a closer look is required to check whether and under what assumptions it is possible to amplify hardness of weakly verifiable puzzles.

Commonly when proving the hardness implication statements of the form
\begin{align*}
  P \implies Q
\end{align*}
where $P$ is a statement that a certain problem is hard, and $Q$ is a certain problem which hardness is implied by $P$.
We use logically equivalent statement
\begin{align*}
  \lnot Q \implies \lnot P.
\end{align*}
Thus, under the assumption that a problem $Q$ is easy, we try to prove that problem $P$ is easy.
This approach is taken by us in this Thesis where in order to show hardness amplification for parallel repetition of weakly verifiable puzzles,
we assume existence of a good algorithm for a parallel repetition of puzzles.
Under this assumption we construct an algorithm that solves a single puzzle with substantial probability.

\section{Weakly Verifiable Puzzles}
Security of cryptographic primitives is often modeled as a game in which an adversary solves a certain problem.
It turns out that a game base security of some cryptographic constructions can be defined as a weakly verifiable puzzle.

If it is not possible for an adversary to efficiently check the correctness of the solution then
we call such a puzzle weakly verifiable. We are interested whether solving a parallel repetition of weakly verifiable puzzles
is considerable harder than solving a single puzzle.

The classical proof of Yao \cite{Goldreich:2000:FCB:519078} relies in the great extent on the fact that
it is possible for an adversary to easily verify correctness of a solution.
Thus, in order to show the hardness amplification for a weakly verifiable puzzle a new approach has to be proposed.

Weakly verifiable puzzles has been introduced and studied by Ran Cannetti, Sahi Halevi, and Michael Steiner in \cite{canetti2004hardness}.
They proved that the parallel repetition of weakly verifiable puzzles indeed amplifies hardness.

There are cryptographic constructions where it is required to solve just a fraction of puzzles of parallel repetition.
A significant example are hard artificial intelligence problems like CAPTCHAs where a human is distinguished from computer programs.
A human has on average an advantage over a computer programs in solving CAPTCHAs, but we can not exclude a situation where it also makes mistakes.

The first proof where a threshold function is used and which shows that it is hard to solve even a fraction of weakly
verifiable puzzles correctly comes from Impagliazzo, Jaiswal, and Kabanets \cite{impagliazzo2007chernoff}.
A similar broaden proof by Dodis, Impagliazzo, Jaiswal, and Kabanets \cite{Dodis:2009:SAI:1530441.1530450}
takes into account situations where a solver for weakly verifiable puzzle can ask a limited number of queries
that helps to efficiently verify a solution. Furthermore, it can obtain limited number of hints that should help to solve a puzzle.
It captures the case of standard security definitions of cryptographic primitives like message authentication codes and signature schemes.
The proof \cite{impagliazzo2007chernoff, Dodis:2009:SAI:1530441.1530450} are technically involved and require non sophisticated intuition.

Holenstein and Schoenebeck \cite{DBLP:journals/corr/abs-1002-3534} give a simple and more general
proof of hardness amplification for weakly verifiable puzzles where only a fraction of puzzles have to be solved correctly.
Furthermore, the puzzles considered by them generalize situations which generalize security of the binding property of bit commitment protocols.
What is more, the proof of Holenstein and Schoenebeck follows a similar intuitive approach as the proof in \cite{canetti2004hardness}.

\section{Contribution of the Thesis}
Our main contribution is applying the proof technique given in \cite{DBLP:journals/corr/abs-1002-3534}
in the context of the dynamic puzzles that are considered in \cite{Dodis:2009:SAI:1530441.1530450}.
As a result we prove that it is possible to amplify hardness of weakly verifiable puzzles where a solver
can ask a number of hint and verification queries, an instance of a puzzle is created in an interactive protocol, and
which puzzles have to solved is determined by a monotone binary function which generalize a situation where only
a fraction of puzzles have to be solved.

\section{Organization of the Thesis}
In Chapter \ref{ch:preliminaries} we lay down notation and terminology used in the Thesis.
We also introduce constructions like \textit{pairwise independent families of efficient hash functions} that are used in later chapters.

Next, in Chapter \ref{ch:intro_weakly} we define \textit{a dynamic interactive weakly verifiable puzzle} and
given an overview of cryptographic primitives that game based security definition can be modeled as
a dynamic interactive weakly verifiable puzzle. Furthermore, we give an outline of earlier studies
of weakly verifiable puzzles.

Finally, in Chapter \ref{ch:main_result} we formulate and prove the main theorem of this Thesis.
Namely, we show that it is possible to amplify hardness of dynamic interactive weakly verifiable puzzles
%
\chapter{Preliminaries}
\label{ch:preliminaries}
\input{preliminaries}

\chapter{Weakly Verifiable Cryptographic Primitives}
\label{ch:intro_weakly}
This chapter gives an overview of weakly verifiable cryptographic primitives.
We start by formulating a definition of a \textit{dynamic interactive weakly verifiable puzzle} in Section \ref{section:wvp}.
To provide the Reader more intuition in Section \ref{section:wvp_examples} we describe a~series of well known cryptographic primitives
that are weakly verifiable. Section \ref{st:previous_results} is devoted to the previous research concerning different types of weakly verifiable puzzles.
%
\input{def_diwvp}
\input{examples}
\input{previous}
%
\section{Limitations of Security Amplification}
%
% the main theorem
\chapter{Hardness amplification for weakly verifiable puzzles}
\label{ch:main_result}
In the previous chapter we gave an overview of the former studies of different types of weakly verifiable puzzles.
We also defined a~more general notion of a~dynamic interactive weakly verifiable puzzle.
The focus of this chapter is on a constructive proof of hardness amplification for dynamic interactive weakly verifiable puzzles.
In Section \ref{st:main_theorem} we formulate the theorem which is then proved in the succeeding sections.
We begin with constructing an algorithm that finds an efficiently computable function that is used
to partition the domain of hint and verification queries. Next, we give a proof of hardness amplification
under the assumption that the domain is well partitioned. Finally, in Section \ref{st:put_together}
we complete the proof by combining the previous steps.
%
% section{Main theorem}
\input{interactive_proof/interactive_proof}
%
% section{Domain partitioning}
\input{interactive_proof/hash_function}
%
% section{Amplification proof for partitioned domain}
\input{interactive_proof/proof}
%
% subsection{Putting it together}
\input{interactive_proof/proofMainThm}
%
\section{Discussion}
\subsection{Optimality of the result}
%
%
\appendix
\input{appendix}

\backmatter

\bibliographystyle{alpha}
\bibliography{refs}

\end{document}
