%% (Master) Thesis template
% Template version used: v1.4
%
% Largely adapted from Adrian Nievergelt's template for the ADPS
% (lecture notes) project.

%% We use the memoir class because it offers a many easy to use features.
\documentclass[11pt,a4paper,titlepage]{memoir}

%% Packages
%% ========

%% LaTeX Font encoding -- DO NOT CHANGE
\usepackage[OT1]{fontenc}

%% Babel provides support for languages.  'english' uses British
%% English hyphenation and text snippets like "Figure" and
%% "Theorem". Use the option 'ngerman' if your document is in German.
%% Use 'american' for American English.  Note that if you change this,
%% the next LaTeX run may show spurious errors.  Simply run it again.
%% If they persist, remove the .aux file and try again.
\usepackage[english]{babel}

%% Input encoding 'utf8'. In some cases you might need 'utf8x' for
%% extra symbols. Not all editors, especially on Windows, are UTF-8
%% capable, so you may want to use 'latin1' instead.
\usepackage[utf8]{inputenc}

%% This changes default fonts for both text and math mode to use Herman Zapfs
%% excellent Palatino font.  Do not change this.
%\usepackage[sc]{mathpazo}

%% The AMS-LaTeX extensions for mathematical typesetting.  Do not
%% remove.
\usepackage{amsmath,amssymb,amsfonts,mathrsfs}

%% NTheorem is a reimplementation of the AMS Theorem package. This
%% will allow us to typeset theorems like examples, proofs and
%% similar.  Do not remove.
%% NOTE: Must be loaded AFTER amsmath, or the \qed placement will
%% break
\usepackage[amsmath,thmmarks]{ntheorem}

%% LaTeX' own graphics handling
\usepackage{graphicx}

%% We unfortunately need this for the Rules chapter.  Remove it
%% afterwards; or at least NEVER use its underlining features.
\usepackage{soul}

%% Some more packages that you may want to use.  Have a look at the
%% file, and consult the package docs for each.
\input{extrapackages}

%% Our layout configuration.  DO NOT CHANGE.
\input{layoutsetup}

%% Theorem environments.  You will have to adapt this for a German
%% thesis.
\input{theoremsetup}

%% Helpful macros.
\input{macrosetup}

%% Make document internal hyperlinks wherever possible. (TOC, references)
%% This MUST be loaded after varioref, which is loaded in 'extrapackages'
%% above.  We just load it last to be safe.
\usepackage[linkcolor=black,colorlinks=true,citecolor=black,filecolor=black]{hyperref}


%% Document information
%% ====================

\title{On amplification of weakly verifiable dynamic cryptographic primitives}
\author{Grzegorz Makosa}
\thesistype{Master Thesis}
\advisors{Advisors: Prof. Dr. Thomas Holenstein, Dr. Robin KÃ¼nzler}
\department{Department of Computer Science}
\date{April 8, 2014}

\begin{document}

\frontmatter

% \begin{titlingpage}
%   \calccentering{\unitlength}
%   \begin{adjustwidth*}{\unitlength-24pt}{-\unitlength-24pt}
%     \maketitle
%   \end{adjustwidth*}
% \end{titlingpage}
%\input{abstract}

\cleartorecto
\tableofcontents
\mainmatter

\chapter{Introduction}
% use term \textit{puzzle} to denote somewhat-hard automatically-generated computational a problems
\section{Security Amplification Theorems}
Introduction to security amplification theorems and hardness implication statements.
Example of classical results. Problems captured by weakly verifiable puzzles.
Contribution of this thesis.
\section{Weakly verifiable puzzles}
\section{Contribution of the Thesis}
\section{Organization of the Thesis}
Overview of the content of the succeeding chapters.

\chapter{Preliminaries}
\input{preliminaries}

\chapter{Weakly Verifiable Cryptographic Primitives}
This chapter give an overview of dynamic weakly verifiable puzzles.
In Section \ref{section:wvp} we define dynamic weakly verifiable puzzles.
The next Section \ref{section:wvp_examples} describes a series of cryptographic primitives that are captured by the notion of dynamic weakly verifiable puzzles.
The Section \ref{st:previous_results} is devoted to the previous research concerning weakly verifiable puzzles.

\begin{todo}
  \textbf{TODO:} $C_n$ ?
\end{todo}

\section{Dynamic Weakly Verifiable Puzzles}
\label{section:wvp}
We consider the following definition of \textit{dynamic weakly verifiable puzzles (DWVP)}.
\begin{definition}[Dynamic Weakly Verifiable Puzzle.]
  \label{def:dwvp}
  A \textnormal{dynamic weakly verifiable puzzle (DWVP)} is defined by a family of probabilistic circuits $\{P_n\}$.
  A circuit belonging to $\{P_n\}$ is called a problem poser.
  A solver $C := (C_1, C_2)$ for $P_n$ is a probabilistic two phase circuit.
  We write $P_n(\pi)$ to denote the execution of $P_n$ with the randomness fixed to $\pi \in \{0,1\}^n$, and $(C_1,C_2)(\rho)$
  to denote the execution of both $C_1$ and $C_2$ with the randomness fixed to $\rho \in \{0,1\}^{*}$.

  In the first phase, the problem poser $P_n(\pi)$ and the solver $C_1(\rho)$ interact.
  As the result of the interaction $P_n(\pi)$ outputs a verification circuit $\Gamma_{V}$ and a hint circuit $\Gamma_{H}$.
  The circuit $C_1(\rho)$ produces no output.
  The circuit $\Gamma_{V}$ takes as input $q \in Q$, an answer $y \in \{0,1\}^*$
  and outputs a bit. We say that an answer $(q,y)$ is a correct solution if and only if $\Gamma_V(q,y) = 1$.
  The circuit $\Gamma_H$ on input $q \in Q$ outputs a hint such that $\Gamma_V(q,\Gamma_H(q)) = 1$.

  In the second phase, $C_2$ takes as input $x := \langle P_n(\pi), C_1(\rho) \rangle_{\mathit{trans}}$,
  and has oracle access to $\Gamma_V$ and $\Gamma_H$.
  The execution of $C_2$ with the input $x$ and the randomness fixed to $\rho$
  is denoted by $C_2(x, \rho)$. The queries of $C_2$ to $\Gamma_V$ and $\Gamma_H$ are called verification queries and hint queries respectively.
  The circuit $C_2$ succeeds if and only if it makes a verification query $(q,y)$ such that $\Gamma_V(q,y) = 1$,
  and it has not previously asked for a hint query on $q$.
\end{definition}

The above definition generalizes and combines previous approaches of
\textit{weakly verifiable puzzles} \cite{canetti2004hardness},
\textit{dynamic weakly verifiable puzzles} \cite{Dodis:2009:SAI:1530441.1530450}
and \textit{interactive weakly verifiable puzzles} \cite{DBLP:journals/corr/abs-1002-3534}.

\begin{todo}
  \textbf{TODO:} This is not some obvious as: a) algorithms are in BPP but they are search problems no languages b) this theorem as for deterministic algorithms
\end{todo}

There is no loss of generality in assuming that a problem poser and a problem solver are defined by probabilistic circuits.
Definition \ref{def:dwvp} embraces also a case where a problem poser and a problem solver are probabilistic polynomial time algorithms.
We use the well know fact \cite{LectureNotesCT} that polynomial time algorithms can be transform into equivalent family of Boolean circuits of polynomial size.

\section{Examples}
\label{section:wvp_examples}
In this section we give examples of cryptographic constructions that are dynamic weakly verifiable puzzles.

\subsection{Message Authentication Codes}
We consider the setting in which two parties a \textit{sender} and a \textit{receiver} communicate over an insecure channel.
The messages of the sender may be read and changed by a third party called an \textit{adversary}.
The receiver needs a way to ensure that received messages have been indeed sent by the sender and have not been modified by the adversary.
The solution is to use message authentication codes.

We consider a setting where sender, receiver, and adversary are polynomial time algorithms, and messages are represented as bitstring.
Additionally, we assume that the sender and the receive share a secrete key to which an adversary has no access.
The sender appends to every message a tag that is as computed as a function of the key and the message.
The receiver, using the key, has a way to check whether the appended tag is valid for the received message.
We say that the receiver accepts if the tag is valid for the received message. Otherwise, the receiver rejects.
We require that it is hard for the adversary to find a tag and a message that is accepted by the receiver with non-negligible probability.
We give the following formal definition of \textit{message authentication code} based on \cite{LectureNotesCrypo} and \cite{Goldreich:2004:FCV:975541}.
\begin{definition}[Message Authentication Codes]
  Let $\cM \subseteq \{0,1\}^*$ be a set of messages, $\cK \subseteq \{0,1\}^{n}$ a set of keys and $\cT \subseteq \{0,1\}^*$ a set of tags where $n \in \N$
  is a security parameter. We define the \textnormal{message authentication code (MAC)} as a function $f:\cM \times \cK \rightarrow \cT$.
  Furthermore, we say that MAC is secure if it satisfies the following condition:

  Let $k \xleftarrow{\$} \cK$ and $\Gamma_H: \cM \rightarrow \cT$ be an oracle computing
  a tag for the key $k$ and a message $m$. We say that MAC is secure if there is no probabilistic polynomial time algorithm with oracle access to $\Gamma_H$
  that with non-negligible probability outputs a message $m'$, as well as corresponding tag $t'$ such that $f(m', k) = t'$,
  and $\Gamma_H$ has not been queried for a tag of message $m'$.
\end{definition}

We show how the above definition of MAC is captured by dynamic interactive weakly verifiable puzzles.
For fixed security parameter $n$ the sender corresponds to a problem poser, the adversary to a problem solver, and
the $k$ key is a bitstring $\pi \in \{0,1\}^{n}$ taken as auxiliary input by a problem poser.
In the first phase, which is non interactive, the problem poser outputs a hint circuit
$\Gamma_H: \cM \rightarrow \cT$ that given a message computes a tag
and a verification circuit $\Gamma_V: \cM \times \cT \rightarrow \{0,1\}$ that on input $m \in \cM$ and $t \in \cT$
outputs one if and only if $f(m, k) = t$.

In the second phase the adversary takes no input ($x^*$ is empty string), as the first phase was non-interactive, and
is given oracle access to $\Gamma_H$ and $\Gamma_V$.
We say that an adversary \textit{succeeds in breaking the security of MAC} if it finds a valid tag $t' \in \cT$ for a message $m' \in \cM$ such that a hint for $m'$
has no been asked before. That corresponds to asking a successful verification query to $\Gamma_V$.
Conversely, if there is no polynomial time algorithm that succeeds in solving this dynamic weakly verifiable puzzle with non-negligible probability
then MAC is secure.
%
\subsection{Public Key Signature Scheme}
\begin{todo}
  \textbf{TODO:} Add introduction that gives intuition about the Public Key Signature Schemes
\end{todo}

First we give a definition of public key encryption scheme, and what it means for such a scheme to be secure.
These definitions are based on \cite{Goldreich:2004:FCV:975541}.

\begin{todo}
  \textbf{TODO:} Length of public and private key
\end{todo}

\begin{definition}[Public key signature scheme]
Let $\cQ$ be the set of messages. A \textnormal{public key signature scheme} is defined by a triple of probabilistic polynomial time algorithms:
$G$ -- the key generation algorithm
$V$ -- the verification algorithm,
$S$ -- the signing algorithm
such that the following conditions are satisfied:
\begin{enumerate}[-]
  \item $G(1^n)$ outputs a pair of bitstrings $k_{priv} \in \{0,1\}^{n}$ and $k_{pub} \in \{0,1\}^{n}$ where $n$ is a security parameter.
    We call $k_{priv}$ a private key and $k_{pub}$ a public key.
  \item The signing algorithm $S$ takes as input $k_{priv}$, $q \in cQ$ and outputs a signature $s \in S$.
  \item The verification algorithm takes as input $k_{pub}$, $q \in cQ$, and $s \in S$ and outputs a bit $b \in \{0,1\}$.
  \item For every $k_{priv}$, $k_{pub}$ output by $G$ and $q \in cQ$ it holds
    \begin{align*}
      \Pr[V(k_{pub}, q, S(k_{priv}, q))] = 1,
    \end{align*}
    where the probability is over random coins of $V$ and $S$.
\end{enumerate}
\end{definition}
We say that signature $s \in S$ is \textit{valid} for $q \in cQ$ if and only if $V(k_{pub}, q, s) = 1$.
%
%TODO efficiency of the algorithms
%
\begin{definition}\textbf{(Security of public key signature scheme with respect to a chosen message attack)}
Let an \textit{adversary} be a probabilistic polynomial time algorithm that takes as input $k_{pub}$ and has oracle access to $S$.
We say that the adversary \textnormal{succeeds in breaking security of public key signature scheme}
if it finds a signature $s \in S$ for a message $q \in cQ$ such that $V(k_{pub}, q, s) = 1$
and the oracle $S$ has not been asked for a signature of $q$.
The public key encryption scheme is \textnormal{secure} if there is no polynomial time algorithm that succeeds in breaking the
security of public key encryption scheme with non negligible probability.
\end{definition}

We show now that public key signature schemes defined as above are dynamic weakly verifiable puzzles.
In the first phase the problem poser uses algorithm $G(1^n)$ to obtain $k_{pub}$ and $k_{priv}$,
the public key $k_{pub}$ is sent to the adversary.
The problem poser generates a hint circuit $\Gamma_H : \cQ \rightarrow S$ and a verification circuit $\Gamma_V : \cQ \times \cS \rightarrow \{0,1\}$.
The hint circuit takes as input $q \in \cQ$ and outputs a signature for $q$. The verification circuit checks whether
signature $s \in S$ is valid for message $q \in \cQ$.
In the second phase the problem solver takes as input $k_{pub}$, and is given oracle access to $\Gamma_V$ and $\Gamma_H$.
It is clear that if the adversary asks a successful verification query $(q,s)$ then it also breaks the security of a public key signature scheme.

Public key signature schemes are type of puzzles that are dynamic - the problem poser gain oracle access to hint and verification circuits,
but are not interactive.
%
\subsection{Bit Commitments}
Let us consider the following \textit{bit commitment protocol} that involves two parties a \textit{sender} and a \textit{receiver}.
We suppose that the sender and the receiver are polynomial time probabilistic algorithms.
The protocol consists of a \textit{commit phase} and \textit{reveal phase}.
In the commit phase the sender and the receiver interact as a result the sender is committed to a value $b \in \{0,1\}$.
In the reveal phase the sender opens the commitment by sending to the receiver $(y,b')$ where $y \in \{0,1\}^{*}$ and $b' \in \{0,1\}$.
We require that after the commit phase it is hard for the receiver to correctly guess $b$.
Additionally, in the \textit{reveal phase} it should be hard for the sender to persuade the receiver that was committed to the value $b' \neq b$.

We base the following definition of Bit Commitment Protocol on \cite{LectureNotesComThCrypto}.
\begin{definition}[Bit Commitment Protocol]
  \label{def:bit_commitment}
For a security parameter $n \in \N$ a \textnormal{bit commitment protocol} is defined by a pair $(S_n, R_n)$
where $S_n = (S_1, S_2)$ is a two phase probabilistic circuit, and $R_n$ is a probabilistic circuit.
The circuits $S_n$ and $R_n$ are of size polynomial in $n$.
The circuit $S_1$, used in the commit phase, takes as input a tuple $(b, \rho_S)$ where $b \in \{0,1\}$ is interpreted as a bit to which $S_n$
commits and $\rho_S \in \{0,1\}^{n}$ is the randomness used by the algorithm $S_n$.
The receiver $R_n$ takes only auxiliary input $\rho_R \in \{0,1\}^{n}$ that is the randomness used by $R_n$.
The protocol consists of two phases. In the commit phase circuits $S_1$, $R_n$ engage in the protocol execution.
As the result $S_1$ commits to $b$ and generates a circuit $V: \{0,1\} \times \{0,1\}^{*} \rightarrow \{0,1\}$.
In the reveal phase the circuit $S_2$ returns $(b', y)$. For fixed $b \in \{0,1\}$ and $n$ we require the bit commit protocol to have the following properties:
\begin{enumerate}[]
\item{\textnormal{\textbf{Correctness}}} For a fixed $b \in \{0,1\}$ we have
  \begin{align*}
    \underset{\substack{V := \langle S_1, R \rangle_{R} \\ (b,y) := S_2(k_{pub}, \rho_S) }}{\Pr}\Big[V(b,y) = 1 \Big] \geq 1 - \epsilon(n),
  \end{align*}
where $\epsilon(n)$ is negligible function of $n$.
\item{\textnormal{\textbf{Hiding}}}
  \begin{todo}
    \textbf{TODO:} Describe it using equations, define somehow the guess of R? Maybe as a last message in the first phase of communication
  \end{todo}
  Probability over random coins of $S_n$ and $R_n$ that any polynomial size circuit
  can guess bit $b$ correctly after the commit phase is at most $\frac{1}{2} + \epsilon(n)$ where $\epsilon(n)$ is a negligible function of $n$.
\item{\textnormal{\textbf{Binding}}}
  For every polynomial size circuit $S_n$ we have
  \begin{align*}
    \underset{\substack{V := \langle S_1, R \rangle_{R} \\ (b,y) := S_2(k_{pub}, \rho_S)}}{\Pr}[V(0,y_0) = 1 \land V(1,y_1) = 1] \leq \epsilon(k),
  \end{align*}
  where $\epsilon(k)$ is a negligible function in $k$.
\end{enumerate}
\end{definition}

The bit commitment protocols can be generalized as weakly verifiable puzzles for a
case where the number of hint queries amounts to zero and the number of the verification queries is at most one.
The sender corresponds to a problem solver and the receiver is a problem poser.
Additionally, we require the problem solver to ask a verification query only on $q := \not b$ where $b$
is a bit to which the problem solver is committed after the first phase.
The first phase corresponds to the commit phase.
In the reveal phase the problem poser tries to find a bitstring $y$ such that $V(\lnot b, y) = 1$.
Thus, breaking the binding property of bit commitment is generalized by an interactive dynamic weakly verifiable puzzle.

\subsection{Automated Turing Tests}
The goal of \textit{Automated Turing Tests} is to distinguish humans from computers which
is frequently used to prevent computer programs from accessing resources for humans.
An example is \textit{CAPTCHA} defined first in \cite{von2003captcha}.
Loossly speaking, CAPTCHA is a test that human can solve with probability close to 1, but it is hard to write a computer program
that has a success probability comparable to the one achieved by humans.
An example of CAPTACHA is an image depicting a distorted text. Most humans guess the text which is displayed on the image correctly, but it might be hard to write
a program for which it would also be easy. We note that the definition of hardness has not been particular well defined ,
and bases on opinions AI community opinions that distinguish between hard and easy AI problems \cite{von2003captcha}.

CAPTCHAs based on guessing the distorted text are weakly verifiable puzzles.
In the first round the problem poser and problem solver engage in interactive protocol, such that
after the execution of the protocol the problem poser has a way to verify the solution.
The problem poser in the second round takes as input a distorted image, and try to guess the text that was used to generated it.
The standard CAPTCHAs are non dynamic, as the problem poser does not gain access to the hint oracle and
asks only a single verification query.

Our definition captures also the above type of problems, additionally it is also applicable in the broader context for a different
AI problems.

As it is not know how good the possible algorithm can be to recognize CAPTCHA it is likely that the gap between human
performance and a performance of computer programs may be small. Therefore, it is of interest to find a way to amplify this gap.
It turns out that it is indeed possible which for not dynamic puzzles was proved in \cite{DBLP:journals/corr/abs-1002-3534}.
The proof presented in Chapter \ref{ch:main_result} applies also to the dynamic context.

% why is it hard to automatically check the solution for CAPTCHAs
%todo define information theoretic security
% \subsection{Information theoretically secure constructions}
% The definition presented in \ref{def:dwvp} applies also to information theoretic secure constructions.

\section{Previous results}
\label{st:previous_results}
\subsection{Results of R.Canetti, S.Halevi, and M.Steiner}
% the matrix with entries, the combinatorial observation.
\subsection{Results of Y.Dodis, R.Impagliazzo, R.Jaiswal, V.Kabanets}
\subsection{Results of T.Holenstein and G.Scheonebeck}
\section{Limitations of Security Amplification}

\input{interactive_proof/interactive_proof}

\appendix
\input{appendix}

\backmatter

\bibliographystyle{alpha}
\bibliography{refs}

\end{document}
