%% (Master) Thesis template
% Template version used: v1.4
%
% Largely adapted from Adrian Nievergelt's template for the ADPS
% (lecture notes) project.

%% We use the memoir class because it offers a many easy to use features.
\documentclass[11pt,a4paper,titlepage]{memoir}

%% Packages
%% ========

%% LaTeX Font encoding -- DO NOT CHANGE
\usepackage[OT1]{fontenc}

%% Babel provides support for languages.  'english' uses British
%% English hyphenation and text snippets like "Figure" and
%% "Theorem". Use the option 'ngerman' if your document is in German.
%% Use 'american' for American English.  Note that if you change this,
%% the next LaTeX run may show spurious errors.  Simply run it again.
%% If they persist, remove the .aux file and try again.
\usepackage[english]{babel}

%% Input encoding 'utf8'. In some cases you might need 'utf8x' for
%% extra symbols. Not all editors, especially on Windows, are UTF-8
%% capable, so you may want to use 'latin1' instead.
\usepackage[utf8]{inputenc}

%% This changes default fonts for both text and math mode to use Herman Zapfs
%% excellent Palatino font.  Do not change this.
%\usepackage[sc]{mathpazo}

%% The AMS-LaTeX extensions for mathematical typesetting.  Do not
%% remove.
\usepackage{amsmath,amssymb,amsfonts,mathrsfs}

%% NTheorem is a reimplementation of the AMS Theorem package. This
%% will allow us to typeset theorems like examples, proofs and
%% similar.  Do not remove.
%% NOTE: Must be loaded AFTER amsmath, or the \qed placement will
%% break
\usepackage[amsmath,thmmarks]{ntheorem}

%% LaTeX' own graphics handling
\usepackage{graphicx}

%% We unfortunately need this for the Rules chapter.  Remove it
%% afterwards; or at least NEVER use its underlining features.
\usepackage{soul}

%% Some more packages that you may want to use.  Have a look at the
%% file, and consult the package docs for each.
\input{extrapackages}

%% Our layout configuration.  DO NOT CHANGE.
\input{layoutsetup}

%% Theorem environments.  You will have to adapt this for a German
%% thesis.
\input{theoremsetup}

%% Helpful macros.
\input{macrosetup}

%% Make document internal hyperlinks wherever possible. (TOC, references)
%% This MUST be loaded after varioref, which is loaded in 'extrapackages'
%% above.  We just load it last to be safe.
\usepackage[linkcolor=black,colorlinks=true,citecolor=black,filecolor=black]{hyperref}

\allowdisplaybreaks[1]

%% Document information
%% ====================

\title{On amplification of weakly verifiable dynamic cryptographic primitives}
\author{Grzegorz Makosa}
\thesistype{Master Thesis}
\advisors{Advisors: Prof. Dr. Thomas Holenstein, Dr. Robin KÃ¼nzler}
\department{Department of Computer Science}
\date{April 8, 2014}

\begin{document}

\frontmatter

% \begin{titlingpage}
%   \calccentering{\unitlength}
%   \begin{adjustwidth*}{\unitlength-24pt}{-\unitlength-24pt}
%     \maketitle
%   \end{adjustwidth*}
% \end{titlingpage}
%\input{abstract}

\cleartorecto
\tableofcontents
\mainmatter

\chapter{Introduction}
\section{Hardness Amplification Theorems}
% Cryptography is science where very little is known about computational hardness of the fundamental problems.
% Furthermore, showing computational hardness of these problems often leads to proving that $P \neq NP$ or showing the existence of one-way functions.
% However, certain problems seem to be more likely to be hard than others.
% Thus, we often study computational hardness of a problem $Q$ under the assumption that a problem $P$ is computationally hard.
%We want the assumptions on which cryptography is based be as weak as possible.
An important and often studied question in Cryptography is whether it is possible to turn a problem
that is only mildly hard into a problem that solving is substantially harder. The statements of this
types are called hardness amplification. One of the most well known result is by Yao \cite{Goldreich:2000:FCB:519078}
that shows that it is possible to build a strong one--way function from a weak one--way function.

In this Thesis we study a question whether it is possible to show a similar result also for basic cryptographic constructions
like signature schemes, message authentication codes, or bit commitment protocols, just to name a few.
Following earlier works, we define a \textit{weakly verifiable puzzle} that generalize many commonly encountered cryptographic primitives.
The characteristic property of a weakly verifiable puzzle is that one does not require that verifying the correctness of a solution by solver to be efficient\footnote{
The word \textit{weakly} in the context of weakly verifiable puzzles is used in a different meaning than for a weak one--way function.
It refers to lack of inefficient solver algorithms for verifying the correctness of solution.}.
An example is CAPTCHA where a problem of checking whether a solution is correct by a solver is comparably hard to finding a correct solution.
On the other hand, we assume that an algorithm that generates an instance of the problem has access to secret information
that makes verifying correctness of a solution easy.

There are two general approaches to amplify hardness. Both base on combining several weakly hard problems which yields
a construction that is strongly hard. First, one can try to use sequential repetition where a protocol is repeated in rounds that start one after another.
It has been observed that sequential repetition amplifies hardness of weakly verifiable puzzles by \cite{von2003captcha}.
However, this approach may be inefficient as it increases the number of rounds creating additional communication burden.

A more useful approach both from the practical and theoretical point is to amplify hardness using parallel repetition.
It has been shown that parallel repetition may fail to amplify hardness \cite{bellare1997does}.
Therefore, closer studies are required to ensure that parallel repetition of weakly verifiable puzzles amplifies hardness.

When amplifying hardness we are interested in showing that a following implication holds
\begin{align*}
  A \implies B
\end{align*}
where $A$ is a statement that a problem $P$ is hard, and $B$ denotes that a problem $Q$ is hard.
It turns out that it is often easier to prove the logically equivalent implication
\begin{align*}
  \lnot B \implies \lnot A.
\end{align*}
Thus, under the assumption that $Q$ is easy, we try to prove that $P$ is also easy.
This approach is used in this Thesis where in order to prove hardness amplification for the parallel repetition of weakly verifiable puzzles,
we assume existence of an algorithm that successfully solves the parallel repetition of weakly verifiable puzzles with substantial probability.
Under this assumption we construct an algorithm that solves a single puzzle with substantial probability.

\section{Weakly Verifiable Puzzles}
Breaking security is often modeled as a game in which an adversary solves a problem.
It turns out that for certain cryptographic schemes a task of winning a game by an adversary
can be shown to be equivalent to solving a weakly verifiable puzzle.
% If it is not possible for an adversary to efficiently check the correctness of the solution then
% we call such a puzzle weakly verifiable. We are interested whether solving a parallel repetition of weakly verifiable puzzles
% is considerable harder than solving a single puzzle.

The proof for one--way function of Yao relies in the great extent on the fact that it is possible
for an adversary to easily verify correctness of a solution. Thus, in order to show the hardness
amplification for a weakly verifiable puzzle a new approach has to be developed.

Weakly verifiable puzzles has been introduced and studied by Cannetti, Halevi, and Steiner in \cite{canetti2004hardness}.
They prove that the parallel repetition of weakly verifiable puzzles is a weakly verifiable puzzle that is substantially harder to solve.

There are cryptographic constructions where it is enough to solve only a fraction of puzzles of the parallel repetition of weakly verifiable puzzle.
A significant example are hard artificial intelligence problems like CAPTCHAs where a human is distinguished from computer programs.
A human has on average an advantage over computer programs in recognizing a distorted text, but we can not exclude a situation where it also makes mistakes.
%Thus, a threshold function is introduced.

The first proof of hardness amplification where a threshold function that decides what fraction of weakly verifiable puzzles has to be solved correctly
in order to successfully solve the parallel repetition is given by Impagliazzo, Jaiswal, and Kabanets \cite{impagliazzo2007chernoff}.
A similar proof by Dodis, Impagliazzo, Jaiswal, and Kabanets \cite{Dodis:2009:SAI:1530441.1530450} additionally
takes into account situations where an adversary can ask a limited number of queries that verify correctness of a solution.
Furthermore, an adversary can obtain limited number of hints that should help to solve a puzzle.
The puzzles defined in this way captures the case of standard security definitions of cryptographic primitives
like message authentication codes and signature schemes. The proofs \cite{impagliazzo2007chernoff, Dodis:2009:SAI:1530441.1530450} are technically
involved and require sophisticated intuition.

Holenstein and Schoenebeck \cite{DBLP:journals/corr/abs-1002-3534} give a simpler and more general
proof of hardness amplification for weakly verifiable puzzles where only a fraction of puzzles have to be solved correctly.
Furthermore, the puzzles considered by them cover a games that model breaking the binding property of a bit commitment protocol.
The proof of Holenstein and Schoenebeck follows a similar intuitive approach as the proof in \cite{canetti2004hardness}.

\section{Contribution of the Thesis}
In this Thesis we apply the proof technique given in \cite{DBLP:journals/corr/abs-1002-3534}
in the context of weakly verifiable puzzles where an adversary can ask hint and verification queries.
%that are considered in \cite{Dodis:2009:SAI:1530441.1530450}.
As a result we prove that it is possible to amplify hardness of weakly verifiable puzzles where an adversary
can ask a limited number of hint and verification queries, an instance of a puzzle is created in an interactive protocol,
and which puzzles of parallel repetition have to be solved is determined by a monotone binary function which generalize
a case where only a fraction of puzzles have to be solved.

\section{Organization of the Thesis}
In Chapter \ref{ch:preliminaries} we lay down notation and terminology used in the Thesis.

Next, in Chapter \ref{ch:intro_weakly} we define \textit{a dynamic interactive weakly verifiable puzzle} and
give an overview of cryptographic primitives that game based security definition can be modeled as
a dynamic interactive weakly verifiable puzzle. Furthermore, we give an outline of earlier studies
of weakly verifiable puzzles and compare it with the results contained in this Thesis.

Finally, in Chapter \ref{ch:main_result} we formulate and prove the main theorem of this Thesis.
Namely, we show that it is possible to amplify hardness of dynamic interactive weakly verifiable puzzles.
%
\chapter{Preliminaries}
\label{ch:preliminaries}
\input{preliminaries}

\chapter{Weakly Verifiable Cryptographic Primitives}
\label{ch:intro_weakly}
This chapter gives an overview of weakly verifiable cryptographic primitives.
We start by formulating a definition of a \textit{dynamic interactive weakly verifiable puzzle} in Section \ref{section:wvp}.
To provide the Reader more intuition in Section \ref{section:wvp_examples} we describe a~series of well known cryptographic primitives
that are weakly verifiable. Section \ref{st:previous_results} is devoted to the previous research concerning different types of weakly verifiable puzzles.
%
\input{def_diwvp}
\input{examples}
\input{previous}
%
\section{Limitations of Security Amplification}
%
% the main theorem
\chapter{Hardness amplification for weakly verifiable puzzles}
\label{ch:main_result}
In the previous chapter we gave an overview of the former studies of different types of weakly verifiable puzzles.
We also defined a~more general notion of a~dynamic interactive weakly verifiable puzzle.
The focus of this chapter is on a constructive proof of hardness amplification for dynamic interactive weakly verifiable puzzles.
In Section \ref{st:main_theorem} we formulate the theorem which is then proved in the succeeding sections.
We begin with constructing an algorithm that finds an efficiently computable function that is used
to partition the domain of hint and verification queries. Next, we give a proof of hardness amplification
under the assumption that the domain is well partitioned. Finally, in Section \ref{st:put_together}
we complete the proof by combining the previous steps.
%
% section{Main theorem}
\input{interactive_proof/interactive_proof}
%
% section{Domain partitioning}
\input{interactive_proof/hash_function}
%
% section{Amplification proof for partitioned domain}
\input{interactive_proof/proof}
%
% subsection{Putting it together}
\input{interactive_proof/proofMainThm}
%
\section{Discussion}
\subsection{Optimality of the result}
%
%
\appendix
\input{appendix}

\backmatter

\bibliographystyle{alpha}
\bibliography{refs}

\end{document}
