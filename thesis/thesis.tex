%% (Master) Thesis template
% Template version used: v1.4
%
% Largely adapted from Adrian Nievergelt's template for the ADPS
% (lecture notes) project.

%% We use the memoir class because it offers a many easy to use features.
\documentclass[11pt,a4paper,titlepage]{memoir}

%% Packages
%% ========

%% LaTeX Font encoding -- DO NOT CHANGE
\usepackage[OT1]{fontenc}

%% Babel provides support for languages.  'english' uses British
%% English hyphenation and text snippets like "Figure" and
%% "Theorem". Use the option 'ngerman' if your document is in German.
%% Use 'american' for American English.  Note that if you change this,
%% the next LaTeX run may show spurious errors.  Simply run it again.
%% If they persist, remove the .aux file and try again.
\usepackage[english]{babel}

%% Input encoding 'utf8'. In some cases you might need 'utf8x' for
%% extra symbols. Not all editors, especially on Windows, are UTF-8
%% capable, so you may want to use 'latin1' instead.
\usepackage[utf8]{inputenc}

%% This changes default fonts for both text and math mode to use Herman Zapfs
%% excellent Palatino font.  Do not change this.
%\usepackage[sc]{mathpazo}

%% The AMS-LaTeX extensions for mathematical typesetting.  Do not
%% remove.
\usepackage{amsmath,amssymb,amsfonts,mathrsfs}

%% NTheorem is a reimplementation of the AMS Theorem package. This
%% will allow us to typeset theorems like examples, proofs and
%% similar.  Do not remove.
%% NOTE: Must be loaded AFTER amsmath, or the \qed placement will
%% break
\usepackage[amsmath,thmmarks]{ntheorem}

%% LaTeX' own graphics handling
\usepackage{graphicx}

%% We unfortunately need this for the Rules chapter.  Remove it
%% afterwards; or at least NEVER use its underlining features.
\usepackage{soul}

%% Some more packages that you may want to use.  Have a look at the
%% file, and consult the package docs for each.
\input{extrapackages}

%% Our layout configuration.  DO NOT CHANGE.
\input{layoutsetup}

%% Theorem environments.  You will have to adapt this for a German
%% thesis.
\input{theoremsetup}

%% Helpful macros.
\input{macrosetup}

%% Make document internal hyperlinks wherever possible. (TOC, references)
%% This MUST be loaded after varioref, which is loaded in 'extrapackages'
%% above.  We just load it last to be safe.
\usepackage[linkcolor=black,colorlinks=true,citecolor=black,filecolor=black]{hyperref}


%% Document information
%% ====================

\title{On amplification of weakly verifiable dynamic cryptographic primitives}
\author{Grzegorz Makosa}
\thesistype{Master Thesis}
\advisors{Advisors: Prof. Dr. Thomas Holenstein, Dr. Robin KÃ¼nzler}
\department{Department of Computer Science}
\date{April 8, 2014}

\begin{document}

\frontmatter

% \begin{titlingpage}
%   \calccentering{\unitlength}
%   \begin{adjustwidth*}{\unitlength-24pt}{-\unitlength-24pt}
%     \maketitle
%   \end{adjustwidth*}
% \end{titlingpage}
%\input{abstract}

\cleartorecto
\tableofcontents
\mainmatter

\chapter{Introduction}
% use term \textit{puzzle} to denote somewhat-hard automatically-generated computational a problems
\section{Security Amplification Theorems}
Introduction to security amplification theorems and hardness implication statements.
Example of classical results. Problems captured by weakly verifiable puzzles.
Contribution of this thesis.
\section{Weakly verifiable puzzles}
\section{Contribution of the Thesis}
\section{Organization of the Thesis}
Overview of the content of the succeeding chapters.

\chapter{Preliminaries}
\input{preliminaries}

\chapter{Weakly Verifiable Cryptographic Primitives}
In this chapter we introduce weakly verifiable puzzles.
Section \ref{section:wvp} contains the formal definitions of dynamic weakly verifiable puzzles.
In Section \ref{section:wvp_examples} we give a series of cryptographic primitives that are captured by dynamic weakly verifiable puzzles.
Finally, in Section \ref{st:previous_results} we give an overview of the earlier research in this area
that is primarily covered in \cite{canetti2004hardness}, \cite{Dodis:2009:SAI:1530441.1530450}, and \cite{DBLP:journals/corr/abs-1002-3534}.

\section{Dynamic Weakly Verifiable Puzzles}
\label{section:wvp}
We start by defining \textit{dynamic weakly verifiable puzzles}.
\begin{definition}[Dynamic weakly verifiable puzzle.]
  \label{def:dwvp}
  A dynamic weakly verifiable puzzle (DWVP) is defined by a family of probabilistic circuits $\{P_n\}$.
  A circuit belonging to $\{P_n\}$ is called a problem poser.
  A solver $C := (C_1, C_2)$ for $P_n$ is a probabilistic two phase circuit.
  We write $P_n(\pi)$ to denote the execution of $P_n$ with the randomness fixed to $\pi \in \{0,1\}^n$, and $(C_1,C_2)(\rho)$
  to denote the execution of both $C_1$ and $C_2$ with the randomness fixed to $\rho \in \{0,1\}^{*}$.

  In the first phase, the problem poser $P_n(\pi)$ and the solver $C_1(\rho)$ interact.
  As the result of the interaction $P_n(\pi)$ outputs a verification circuit $\Gamma_{V}$ and a hint circuit $\Gamma_{H}$.
  The circuit $C_1(\rho)$ produces no output.
  The circuit $\Gamma_{V}$ takes as input $q \in Q$, an answer $y \in \{0,1\}^*$,
  and outputs a bit. We say that an answer $(q,y)$ is a correct solution if and only if $\Gamma_V(q,y) = 1$.
  The circuit $\Gamma_H$ on input $q \in Q$ outputs a hint such that $\Gamma_V(q,\Gamma_H(q)) = 1$.

  In the second phase, $C_2$ takes as input $x := \langle P_n(\pi), C_1(\rho) \rangle_{\mathit{trans}}$,
  and has oracle access to $\Gamma_V$ and $\Gamma_H$.
  The execution of $C_2$ with the input $x$ and the randomness fixed to $\rho$
  is denoted by $C_2(x, \rho)$. The queries of $C_2$ to $\Gamma_V$ and $\Gamma_H$ are called verification queries and hint queries respectively.
  The circuit $C_2$ succeeds if and only if it makes a verification query $(q,y)$ such that $\Gamma_V(q,y) = 1$,
  and it has not previously asked for a hint query on $q$.
\end{definition}

The above definition generalizes the previous approaches contained in \cite{canetti2004hardness}, \cite{Dodis:2009:SAI:1530441.1530450}, \cite{DBLP:journals/corr/abs-1002-3534}.
Some of more interesting cryptographic primitives captured by this definition are described in Section \ref{section:wvp_examples}.
There is no loss of generality in assuming that a problem poser and problem solver are defined by probabilistic circuits.
The definition embraces also a case a problem poser and a problem solver are probabilistic polynomial time algorithms
by using the well know fact \cite{LectureNotesCT} that probabilistic algorithms can be transform into equivalent family of Boolean circuits of polynomial size.

\section{Examples}
\label{section:wvp_examples}
In this section we give examples of cryptographic constructions that are dynamic weakly verifiable puzzles.

\subsection{Message Authentication Codes}
We consider the setting in which two parties a \textit{sender} and a \textit{receiver} communicate over an insecure channel, and
messages of the sender may be read and changed by a third party called an \textit{adversary}.
The receiver needs a way to ensure that received messages are indeed sent by the sender and have not been modified by the adversary.
The solution is to use message authentication codes.

We assume that all parties are polynomial time algorithms, and messages can be represented as bitstring.
Additionally, we assume that the sender and the receive share a secrete key to which an adversary has no access.
The sender appends to every message a tag that is as computed as a function of the key and the message.
The receiver, using the key, has a way to check whether the tag is valid for the received message.
On the other hand, it should be hard for the adversary to find a tag and message that would be correctly validate by the receiver.

We give the following more formal definition based on \cite{LectureNotesCrypo} and \cite{Goldreich:2004:FCV:975541}.
\begin{definition}[Message Authentication Codes (MAC)]
  Let $\cM \subseteq \{0,1\}^*$ be a set of messages, $\cK \subseteq \{0,1\}^{n}$ a set of keys and $\cT \subseteq \{0,1\}^*$ a set of tags where $n \in \N$
  is a security parameter. We define the \textit{message authentication code} as function $f:\cM \times \cK \rightarrow \cT$. Furthermore, we say
  that the message authentication code is secure if it satisfies the following condition:

  Let $k$ be chosen uniformly at random from $\cK$ and $\Gamma_H: \cM \rightarrow \cT$ be an oracle computing
  a tag for the key $k$ and a message $m$. We say that MAC is secure if there is no probabilistic polynomial time algorithm with oracle access to $\Gamma_h$
  that with non-negligible probability outputs a message $m'$, as well as corresponding MAC $t'$ such that $f(m', k) = t'$
  and $\Gamma_H$ has not been queried for a tag of message $m'$.
\end{definition}

We show how the above definition of MAC is captured by dynamic weakly verifiable puzzles.
The sender corresponds to a problem poser, and the adversary is a problem solver.
The first phase is non interactive. The $k$ key corresponds to a bitstring $\pi \in \{0,1\}^{n}$ taken by a problem poser $P_n$.
The problem poser outputs a hint circuit $\Gamma_H: \cM \rightarrow \cT$ that given a message computes a tag
and a verification circuit $\Gamma_V: \cM \times \cT \rightarrow \{0,1\}$ that on input $m \in \cM$ and $t \in \cT$
outputs one if and only if $f(m, k) = t$.

In the second phase the adversary takes no input ($x^*$ is empty string), but is given oracle access to $\Gamma_H$ and $\Gamma_V$.
The adversary succeeds in breaking the security of MAC if it finds a valid tag $t' \in \cT$ for a message $m' \in \cM$ such that a hint for this message
has no been asked before. That corresponds to asking a successful verification query to $\Gamma_V$.
Conversely, if there is no polynomial time algorithm that succeeds in solving this dynamic weakly verifiable puzzle with non-negligible probability
then the message authentication code is secure.

Thus, a game in which an adversary has to break security of MAC is a non interactive dynamic weakly verifiable puzzle.

\subsection{Public Key Signature Scheme}
First we give a definition of public key encryption scheme and security of such a scheme. Both definition are based on \cite{Goldreich:2004:FCV:975541}.

\begin{definition}[Public key signature scheme]
A public key encryption scheme is defined by a triple of probabilistic polynomial time algorithms:
$G$ the key generation algorithm, $V$ the verification algorithm, $S$ the verification algorithm such that the following conditions are satisfied:
\begin{enumerate}[]
  \item $G(1^n)$ outputs a pair of bitstrings $k_{priv}$ a private key, $k_{pub}$ a public key.
  \item For every $k_{priv}$, $k_{pub}$ output by $G$ and $q \in Q$ it holds
    \begin{align*}
      \Pr[V(k_{pub}, q, S(k_{priv}, q))] = 1.
    \end{align*}
\end{enumerate}
\end{definition}

%TODO efficiency of the algorithms

\begin{definition}\textbf{(Security of public key signature scheme with respect to the chosen message attack)}
Let us consider a situation in which an adversary is given a public key $k_{pub}$ and can ask for a signature of chosen messages.
We say that the adversary succeeds if it finds a valid signature for a message for which a signature has not been asked.
Furthermore, we say that the public key encryption scheme is secure if probability that any polynomial time bounded adversary
succeeds in breaking the signature scheme with negligible probability.
\end{definition}

We show now that the public key signature schemes are also captured by definition \ref{def:dwvp}.
First the problem poser uses algorithm $G(1^n)$ to obtain a public and private key.
Then it generates a hint circuit $\Gamma_H : \cM \rightarrow S$ and a verification circuit $\Gamma_V : \cM \times \cS \rightarrow \{0,1\}$.
The hint circuit takes as input $m \in \cM$ and outputs a signature for $m$. The verification circuits checks whether
signature $s \in S$ is a valid for message $m \in \cM$.
In the second phase the problem solver obtains $k_{pub}$, and is given oracle access to the hint circuit and verification circuit.
The problem solver can ask a hint oracle for signature on chosen message.

Finally, it is clear that if a problem solver succeeds in solving a DWVP defined as above, it also breaks the secuirty of the public signature schemes.

Public key signature schemes are type of puzzles that are dynamic - the problem poser gain oracle access to hint and verification circuits,
but are not interactive.

%todo define negligible
%todo define computational security
\subsection{Bit Commitments}
\cite{LectureNotesComThCrypto}
Let us consider a bit commitment protocol, in which there are two parties a \textit{sender} and a \textit{receiver}.
In the first phase the sender and the receiver interact and the sender commit to a value $b \in \{0,1\}$.
We require that it is hard for the sender, after the commitment phase, to guess correctly the bit $b$.
In the send phase the sender open the commitment by sending to the receiver the information $y$ that let
the receiver validate the commitment.
We say that the protocol is secure if it is computationally hard for the sender to find to such strings $y_0$ and $y_1$
that both $(0, y_0)$ and $(1, y_1)$ are valid.

\begin{todo}
  \textbf{TODO:} Security definition
\end{todo}

\begin{todo}
  \textbf{TODO:} Type of puzzles generalized by this
\end{todo}

\subsection{Automated Turing Tests}
The goal of \textit{Automated Turing Tests} is to distinguish humans from computers.
A frequent application of \textit{Automated Turing Tests} is preventing computer programs from accessing resources
for human beings (like creating an email account).
An example of implementation of \textit{Automated Turing Tests} is CAPTCHA that was defined in \cite{von2003captcha}.
Loossly speaking, CAPTCHA is a test that human can solve with probability close to 1, but it is hard to write a computer program
that has a success probability comparable to the one achieved by humans.
An example of CAPTACHA is sending a distorted text. It is easy for most humans to guess the right text, but it might be hard to write
a program for which it would also be easy. We note that the definition of hardness is not precesily defined, as it is possible that
there exists a program that reaches the success probability close to the one achieved by humans.

CAPTCHAs basing on guessing the distorted text are yet another example of weakly verifiable puzzles.
In the first round the problem poser and problem solver engage in interactive protocol, such that
after the execution of the protocol the problem poser has a way to verify the solution.
The problem poser in the second round takes as input a distorted image, and try to guess the text that was used to generated it.
We note that the standard distorted text base CAPTCHAs are non dynamic. The problem poser does not gain access to the hint oracle,
only to the verification oracle to which it asks a single query.

Our definition captures also this the above type of problems, additionally it is also applicable in the broader context for a different
AI problems.

As it is not know how good the possible algorithm can be to recognize CAPTCHA it is likely that the gap between human
performance and a performance of computer programs may be small. Therefore, it is of interest to find
a way to amplify this gap.
It turns out that it is indeed possible which for not dynamic puzzles was proved in \cite{DBLP:journals/corr/abs-1002-3534}.
The proof presented in \ref{ch:main_result} applies also to dynamic context.

% why is it hard to automatically check the solution for CAPTCHAs

%todo define information theoretic security
% \subsection{Information theoretically secure constructions}
% The definition presented in \ref{def:dwvp} applies also to information theoretic secure constructions.

\section{Previous results}
\label{st:previous_results}
\subsection{Results of R.Canetti, S.Halevi, and M.Steiner}
% the matrix with entries, the combinatorial observation.
\subsection{Results of Y.Dodis, R.Impagliazzo, R.Jaiswal, V.Kabanets}
\subsection{Results of T.Holenstein and G.Scheonebeck}
\section{Limitations of Security Amplification}

\input{interactive_proof/interactive_proof}

\appendix
\input{appendix}

\backmatter

\bibliographystyle{alpha}
\bibliography{refs}

\end{document}
