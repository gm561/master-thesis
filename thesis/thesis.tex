%% (Master) Thesis template
% Template version used: v1.4
%
% Largely adapted from Adrian Nievergelt's template for the ADPS
% (lecture notes) project.

%% We use the memoir class because it offers a many easy to use features.
\documentclass[11pt,a4paper,titlepage]{memoir}

%% Packages
%% ========

%% LaTeX Font encoding -- DO NOT CHANGE
\usepackage[OT1]{fontenc}

%% Babel provides support for languages.  'english' uses British
%% English hyphenation and text snippets like "Figure" and
%% "Theorem". Use the option 'ngerman' if your document is in German.
%% Use 'american' for American English.  Note that if you change this,
%% the next LaTeX run may show spurious errors.  Simply run it again.
%% If they persist, remove the .aux file and try again.
\usepackage[english]{babel}

%% Input encoding 'utf8'. In some cases you might need 'utf8x' for
%% extra symbols. Not all editors, especially on Windows, are UTF-8
%% capable, so you may want to use 'latin1' instead.
\usepackage[utf8]{inputenc}

%% This changes default fonts for both text and math mode to use Herman Zapfs
%% excellent Palatino font.  Do not change this.
%\usepackage[sc]{mathpazo}

%% The AMS-LaTeX extensions for mathematical typesetting.  Do not
%% remove.
\usepackage{amsmath,amssymb,amsfonts,mathrsfs}

%% NTheorem is a reimplementation of the AMS Theorem package. This
%% will allow us to typeset theorems like examples, proofs and
%% similar.  Do not remove.
%% NOTE: Must be loaded AFTER amsmath, or the \qed placement will
%% break
\usepackage[amsmath,thmmarks]{ntheorem}

%% LaTeX' own graphics handling
\usepackage{graphicx}

%% We unfortunately need this for the Rules chapter.  Remove it
%% afterwards; or at least NEVER use its underlining features.
\usepackage{soul}

%% Some more packages that you may want to use.  Have a look at the
%% file, and consult the package docs for each.
\input{extrapackages}

%% Our layout configuration.  DO NOT CHANGE.
\input{layoutsetup}

%% Theorem environments.  You will have to adapt this for a German
%% thesis.
\input{theoremsetup}

%% Helpful macros.
\input{macrosetup}

%% Make document internal hyperlinks wherever possible. (TOC, references)
%% This MUST be loaded after varioref, which is loaded in 'extrapackages'
%% above.  We just load it last to be safe.
\usepackage[linkcolor=black,colorlinks=true,citecolor=black,filecolor=black]{hyperref}

\allowdisplaybreaks[1]

%% Document information
%% ====================

\title{On amplification of weakly verifiable dynamic cryptographic primitives}
\author{Grzegorz Makosa}
\thesistype{Master Thesis}
\advisors{Advisors: Prof. Dr. Thomas Holenstein, Dr. Robin KÃ¼nzler}
\department{Department of Computer Science}
\date{April 8, 2014}

\begin{document}

\frontmatter

% \begin{titlingpage}
%   \calccentering{\unitlength}
%   \begin{adjustwidth*}{\unitlength-24pt}{-\unitlength-24pt}
%     \maketitle
%   \end{adjustwidth*}
% \end{titlingpage}
%\input{abstract}

\cleartorecto
\tableofcontents
\mainmatter

\chapter{Introduction}
\section{Security Amplification Theorems}
The cryptography is a science where not much is known about the computational lower bounds of certain problems
as many of them would lead to proving (or disproving) that $P \neq NP$.
However, certain problems seems to be more likely to be hard than others.
Thus, we often suppose that a certain problem $P$ is hard and under this assumption
study hardness of a problem $Q$.

An arising question is whether it is possible to turn a problem $P$ that is only mildly hard to solve into a problem $Q$
that solving is much harder. The statements of this types are called hardness amplification.
One of the most well known results is by Yao who proved that it is indeed possible to build a strongly secure one way function
from a one way function that is only weakly secure. The proof of Yao requires inverting correctly certain number of weak one-way function
which yields a function that is one-way.

We are interested in a question whether it is possible to achieve a similar result holds also for other basic cryptographic constructions
like signature schemes, message authentication codes, bit commitment protocols, or artificial intelligence problems, just to name a few.

In this Thesis we study \textit{weakly verifiable puzzles} that generalize many commonly encountered cryptographic primitives.
The characteristic property of weakly verifiable puzzles is that we do not insist that verifying the correctness of a solution by a problem
solver is efficient. An example is CAPTCHA where a problem of checking whether a solution is correct is comparable hard to finding a correct solution.
We give a single proof of hardness amplification for all these primitives.

In general there are two methods to amplify hardness.
The first one is sequentially repetition where a protocol is repeated such that one round starts after the previous is finished.
It has been observed that sequential repetition amplifies hardness of weakly verifiable puzzles by \cite{von2003captcha}.
However, this approach is costly as it increase number of rounds creating additional communication burden.

Therefore, the approach that is more useful from practical point of view is the hardness amplification by means of the
parallel repetition where all puzzles are send at once. We state that it has been shown that parallel repetition
does not always amplify hardness \cite{bellare1997does}.

Commonly when proving the reduction statements of the form
\begin{align*}
  P \implies Q
\end{align*}
where $P$ is a statement that certain problem is hard, and $Q$ is a certain problem which hardness is implied by $P$.
We use logically equivalent statement
\begin{align*}
  \lnot Q \implies \lnot P.
\end{align*}
This means that we under the assumption that a problem $Q$ is easy, we try to prove that problem $P$ is easy.
This approach is also taken by us in this Thesis where in order to show hardness amplification for parallel repetition,
we assume that there exists an algorithm that solves direct product of puzzle with substantial probability.
Under this assumption we show that there exists a solver for a single puzzle with access to the solver for direct product of puzzles that
probability of solving a single puzzle is also substantial.

\section{Weakly verifiable puzzles}
Security of cryptographic primitives is often defined by
a game in which an adversary has access to certain resources, but must not solve a certain problem.
The game base security for many cryptographic constructions can be modeled as a puzzle.
If it is not possible for an adversary to efficiently check the correctness of the solution then
we call such a puzzle weakly verifiable. We are interested whether how to amplify hardness of this game
and whether solving parallel repetition is considerable harder for the adversary.

The classical proof of Yao found in \cite{Goldreich:2000:FCB:519078} relies in the great extent on the fact that
it is easy to verify correctness of a solution.
Thus, in order to show the hardness amplification for weakly verifiable puzzles a different approach has to be found.

Weakly verifiable puzzles has been introduced and studied by Ran Cannetti, Sahi Halevi, and Michael Steiner in \cite{canetti2004hardness}.
They proved that simultaneous solving a number of weakly verifiable puzzles is much harder than solving a single puzzle.

There are situations where we do not require that all puzzles are solved but just a fraction of them.
A prominent example are hard AI problems like CAPTCHAs where a human and computer programs should be distinguished.
A human has an advantage over a computer programs in solving certain problems, but still it is possible to make mistakes.

The first proof where a threshold function is used and which show that it is hard to solve even a fraction of weakly
verifiable puzzles correctly comes from by Russell Impagliazzo, Ragesh Jaiswal, and Valentine Kabanets \cite{impagliazzo2007chernoff}.
A similar broaden proof by Yevgeniy Dodis, Russell Impagliazzo, Ragesh Jaiswal, and Valentine Kabanets \cite{Dodis:2009:SAI:1530441.1530450}
takes into account situations where a solver for weakly verifiable puzzle can ask limited number of queries
that helps to efficiently verify a solution, and can obtain limited number of hints that should help to solve a puzzle.
It captures the case of cryptographic primitives like message authentication codes and signature schemes.
However, both these proof are technically involved and require non trivial intuition.

Thomas Holenstein and Grant Schoenebeck \cite{DBLP:journals/corr/abs-1002-3534} gave a simple and more general proof of hardness amplification for of weakly verifiable puzzles
where only a fraction of puzzles have to be solved correctly.
Furthermore, the puzzles considered by them generalized a situations where a two parties a solve and a puzzle poser intact in an interactive protocol before
a solver is given a puzzle to solve. Such an approach generalize to bit commitment protocols.
What is more, the proof given by Thomas Holenstein and Grant Schoenebeck follows a similar intuitive approach as a proof given in \cite{canetti2004hardness}.

\section{Contribution of the Thesis}
Our main contribution is applying the proof technique given in \cite{DBLP:journals/corr/abs-1002-3534}
in the context of dynamic puzzles that are considered in \cite{Dodis:2009:SAI:1530441.1530450}.
As a result we prove that it is possible to amplify hardness of weakly verifiable puzzles where a solver
can ask hint and verification queries, an instance of a puzzle is created in an interactive protocol, and
which puzzles have to solved is determined by a monotone binary function which generalize a situation where only
a fraction of puzzles have to be solved.

\section{Organization of the Thesis}
In Chapter \ref{ch:preliminaries} we lay down notation and terminology used in the Thesis.
We introduce constructions like pairwise independent hash functions used in later chapters.

Then, in Chapter \ref{ch:intro_weakly} we define a dynamic interactive weakly verifiable puzzle and
given an overview of cryptographic primitives that game based security definition can be modeled as
a puzzle. Furthermore, we give an outline of earlier studies of weakly verifiable puzzles, and
compare it to the puzzles studied in this Thesis.

Finally, in Chapter \ref{ch:main_result} we formulate and prove the main theorem of this Thesis that
shows that it is possible to amplify hardness of dynamic interactive weakly verifiable puzzles.

\chapter{Preliminaries}
\label{ch:preliminaries}
\input{preliminaries}

\chapter{Weakly Verifiable Cryptographic Primitives}
\label{ch:intro_weakly}
This chapter gives an overview of weakly verifiable cryptographic primitives.
We start by formulating a definition of a \textit{dynamic interactive weakly verifiable puzzle} in Section \ref{section:wvp}.
To provide the Reader more intuition in Section \ref{section:wvp_examples} we describe a~series of well known cryptographic primitives
that are weakly verifiable. Section \ref{st:previous_results} is devoted to the previous research concerning different types of weakly verifiable puzzles.
%
\input{def_diwvp}
\input{examples}
\input{previous}
%
\section{Limitations of Security Amplification}
%
% the main theorem
\chapter{Hardness amplification for weakly verifiable puzzles}
\label{ch:main_result}
In the previous chapter we gave an overview of the former studies of different types of weakly verifiable puzzles.
We also defined a~more general notion of a~dynamic interactive weakly verifiable puzzle.
The focus of this chapter is on a constructive proof of hardness amplification for dynamic interactive weakly verifiable puzzles.
In Section \ref{st:main_theorem} we formulate the theorem which is then proved in the succeeding sections.
We begin with constructing an algorithm that finds an efficiently computable function that is used
to partition the domain of hint and verification queries. Next, we give a proof of hardness amplification
under the assumption that the domain is well partitioned. Finally, in Section \ref{st:put_together}
we complete the proof by combining the previous steps.
%
% section{Main theorem}
\input{interactive_proof/interactive_proof}
%
% section{Domain partitioning}
\input{interactive_proof/hash_function}
%
% section{Amplification proof for partitioned domain}
\input{interactive_proof/proof}
%
% subsection{Putting it together}
\input{interactive_proof/proofMainThm}
%
\section{Discussion}
\subsection{Optimality of the result}
%
%
\appendix
\input{appendix}

\backmatter

\bibliographystyle{alpha}
\bibliography{refs}

\end{document}
