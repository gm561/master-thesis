\label{st:previous_results}
In the last chapter we gave an overview of different types of cryptographic primitives that motivated studies of weakly verifiable puzzles.
The focus of this chapter is on giving the outline of the previous research concerning different types of weakly verifiable puzzles
We give a short overview of the techniques used in the series of papers \cite{canetti2004hardness, Dodis:2009:SAI:1530441.1530450, DBLP:journals/corr/abs-1002-3534}
and aim to provide some intuition and insight into the problem of the hardness amplification for dynamic interactive weakly verifiable puzzles.
First, we introduce the notion of the \textit{weakly verifiable puzzles} that are neither interactive nor dynamic and are studied in
\cite{canetti2004hardness}. Then, in Section \ref{section:dijk} we bring our focus on the dynamic non-interactive puzzles studies in \cite{Dodis:2009:SAI:1530441.1530450}.
Finally, in Section \ref{section:iwvp} we give an overview of results of Holenstein and Schoenebeck \cite{DBLP:journals/corr/abs-1002-3534} where
non-dynamic and interactive weakly verifiable puzzles have been studied.
%
\section{Weakly Verifiable Puzzles}
\label{subsec:chs}
The notion of \textit{weakly verifiable puzzles} has been coined by Canetti, Halevi, and Steiner in the paper
\textit{Hardness amplification of weakly verifiable puzzles} \cite{canetti2004hardness}.
In comparison to Definition \ref{def:dwvp} the puzzles considered in \cite{canetti2004hardness} are non-dynamic and non-interactive.
Moreover, the number of verification queries is limited to one. This constitutes a special case of Definition \ref{def:dwvp}.
In this section we provide the definition of weakly verifiable puzzles (WVP) that closely follows the one contained in \cite{canetti2004hardness}
and state the theorem of hardness amplification of weakly verifiable puzzles in a similar vein as in \cite{canetti2004hardness}.
Finally, we give an intuition behind the proof of this theorem. It is noteworthy that the main proof of this Thesis, contained in Chapter \ref{ch:main_result},
uses many ideas of the work of Canetti, Halevi, and Steiner \cite{canetti2004hardness}.
%
\subsection{The definition}
The following definition corresponds to the definition of weakly verifiable puzzles from \cite{canetti2004hardness}
but uses the notation and terminology used in this Thesis.

\begin{definition}[Weakly Verifiable Puzzles, informal \cite{canetti2004hardness}]
  \label{def:wvp}
A \textit{weakly verifiable puzzle} is defined by a pair of polynomial time algorithms:
a probabilistic puzzle--generation algorithm $G$ and a deterministic verification algorithm $V$.
We write $G(1^k; \rho)$ to denote that $G$ takes as input a bitstring $1^k$, where $k$ is a security parameter,
and the randomness $\rho \in \{0,1\}^{*}$.
The algorithm $G$ outputs a bitstring $p \in \{0,1\}^{*}$ and a check information $c \in \{0,1\}^{*}$.
The \textnormal{verifier} $V$ is a deterministic algorithm that takes as input $p$, $c$, an answer $a \in \{0,1\}^{*}$
and outputs $b \in \{0,1\}$.

A \textnormal{solver} $S$ for $G$ is a polynomial time probabilistic algorithm that
takes as input $p$ and outputs $a$. We denote the randomness used by $S$ as $\pi \in \{0,1\}^{*}$
and define the \textnormal{success probability} of $S$ in solving a puzzle defined by $P$ as
\begin{align*}
  \underset{\substack{\rho \in \{0,1\}^{*}, \pi \in \{0,1\}^{*} \\ (p,c):=G(1^k; \rho) \\ a := S(p, \pi)}}{\Pr}\Big[ V(p,c,a) = 1\Big].
\end{align*}
We write $P := (G,V)$ to denote a weakly verifiable puzzle $P$ defined by algorithms $G$ and $V$.
\end{definition}
We compare the above definition with Definition \ref{def:dwvp}.
First, we note that in Definition \ref{def:dwvp} we use the language of probabilistic circuits.
This is more general than probabilistic polynomial time algorithms.
Next, we see that in Definition \ref{def:wvp} the algorithm $G$ is parameterized by
a bitstring $1^k$ meaning that the length of a random bitstring taken by $G$ is bounded by $poly(k)$.
For a fixed $k$, without loss of generality, we can model the algorithm $G(1^k; \rho)$ as a polynomial size probabilistic circuit
that does not take as input $1^k$, but just a bitstring $\rho$ of length $\mathit{poly}(k)$.
The security parameters from Definition \ref{def:wvp} and Definition \ref{def:dwvp} are not equivalent,
as in the later definition the security parameter limits the length of the random bistring.
Moreover, in Definition \ref{def:wvp} a verification algorithm takes as input $p$, $c$, $a$.
Again, without loss of generality, we can assume that bitstrings $p$ and $c$ are hard-coded
in the circuit $\Gamma_V$ from Definition \ref{def:dwvp}. Hence, the algorithm $V$ corresponds to $\Gamma_V$.
The puzzles considered in Definition \ref{def:wvp} are non--dynamic. Thus, there is no corresponding
element for a hint circuit $\Gamma_H$ from Definition~\ref{def:dwvp}.
Finally, the puzzles described in Definition~\ref{def:wvp} are non--interactive.

\subsection{The hardness amplification}
We will formulate now the definition of the $n$-fold repetition of weakly verifiable puzzles along the lines of \cite{canetti2004hardness}.
Later in this Thesis, for other types of weakly verifiable puzzles, we use the notion of a $k$-wise direct product of puzzles instead\footnote{We
note that the terminology used to name the parallel repetition of weakly verifiable puzzles is not consistent.
In \cite{canetti2004hardness} the notion of the \textit{$n$-fold direct product of puzzles} is used whereas in \cite{Dodis:2009:SAI:1530441.1530450}
a similar construction that captures dynamic puzzles is named the \textit{$k$-wise repetition of puzzles}.
In this Thesis we use the latter name.}.
%
\begin{definition}\textbf{($n$-fold repetition of weakly verifiable puzzles, \cite{canetti2004hardness}.)}
  \label{def:n-fold-rep}
  Let $n~\in~\N$ and a weakly verifiable puzzle $P = (G,V)$ be fixed.
  We define the $n$-fold repetition of $P$ as a weakly verifiable puzzle where the puzzle--generation algorithm
  $G^{(n)}$ takes as input $1^k$, as an auxiliary input a bitstring $\rho \in \{0,1\}^{*}$
  and outputs tuples $p^{(n)} := (p_1, \dotsc, p_n) \in \{0,1\}^{*}$ and $c^{(n)} := (c_1, \dotsc, c_k) \in \{0,1\}^{*}$
  where for each $1 \leq i \leq n$ a pair $(p_i, c_i)$ is an independent instance of a weakly verifiable puzzle defined by $G$ and $V$ with security parameter $k$.
  Finally, the verification algorithm $V^{(n)}$ takes as input $p^{(n)}$, $c^{(n)}$, an answer $a^{(n)}$, and outputs $b \in \{0,1\}$
  such that $b = 1$ if and only if for all $1 \leq i \leq n$ we have $V(p_i, c_i, a_i) = 1$.
 \end{definition}
%
Let us give some notation and terminology. We write $P^{(n)} := (G^{(n)}, V^{(n)})$ to denote the $n$--fold repetition of $P$.
For $P^{(n) } := (G^{(n)},V^{(n)})$ when writing a \textit{puzzle on the $i$-th coordinate} we refer to the $i$-th puzzle of the $n$--fold repetition of WVP
(this puzzle corresponds to the one generated by $G^{(n)}_i$,  $V^{(xn)}_i$).

The $n$-fold repetition of weakly verifiable puzzles is solved successfully if and only if all $n$ puzzles are solved successfully.
In contrast, in Chapter \ref{ch:main_result} we are interested in a more general situation where a monotone function $g: \{0,1\}^{n} \rightarrow \{0,1\}$ is used to decide
which coordinates of the $n$-fold repetition of puzzles have to be solved correctly. A precise definition is given in Section \ref{st:main_theorem}.
Clearly, we can assume that $g$ is such that all coordinates have to be solved successfully which matches the case considered in this section.

The main theorem proved in \cite{canetti2004hardness} states that it is possible to turn a good solver for $P^{(n)}$ to a good solver for $P$.
%
\begin{theorem}[Hardness amplification of weakly verifiable puzzles, \cite{canetti2004hardness}]
  \label{thm:wvp_chs}
Let $n:\N \rightarrow \N$ and $\delta: \N \rightarrow (0,1)$ be efficiently computable functions and $q \in \N$ a \textit{slackness parameter}.
Moreover, let $P = (G,V)$ be a weakly verifiable puzzle. We denote the running time of the
puzzle--generation algorithm $G$ for $P$ by $T_G$ and of the verification algorithm $V$ for $P$ by $T_V$.
If $S^{(n)}$ is a solver for the $n$--fold repetition of $P$ that success probability is at least $\delta^{n}$
and the running time is $T$, then there exists a solver $S$ for $G$ with oracle access to $S^{(n)}$ that success
probability is at least $\delta(1-\frac{1}{q})$ and the running time is $O\Big(\frac{nq^3}{\delta^{2n-1}}(T + nT_G + nT_V)\Big)$.
\end{theorem}
%
The following algorithm is used in \cite{canetti2004hardness} to prove Theorem \ref{thm:wvp_chs}.
It transforms $S^{(n)}$ for $P^{(n)}$ with success probability at least $\delta^{n}$ to a solver for a single puzzle $P$ with probability
at least $\delta(1  - \frac{1}{q})$. The slackness parameter $q$ is introduced as it is not possible to achieve
the perfect hardness amplification. We note that in the analysis of the running time of $\mathit{CHS\text{--}solver}$
we explicitly take into account the time needed for the oracle calls to $S^{(n)}, V, G$.

Let us denote by $p \in \{0,1\}^{*}$ an output of $G$, which is taken as input by $\mathit{CHS\text{--}solver}$.
To make notation shorter in the following code excerpts we do not write randomness used by $G$ explicitly.

\begin{codeblock}
  \textbf{Algorithm:} $\mathit{CHS\text{--}solver}^{S^{(n)},V,G}(p, n, k, q, \delta)$
  \medskip\hrule
  \textbf{Oracle:} A solver $S^{(n)}$ for $P^{(n)}$, a verification algorithm $V$ for $P$, a puzzle--generation algorithm $G$ for $P$.\\
  \textbf{Input:}  A bistring $p \in \{0,1\}^{*}$, parameters $n, k, q, \delta$.
  \medskip\hrule
  $\mathit{prefix} := \emptyset$\\
  \For $i = 1$ \To $n\!-\!1$ \Do \\
  \IndI $p^* := \mathit{ExtendPrefix}^{S^{(n)}, V, G}(\mathit{prefix}, i, n, k, q, \delta)$\\
  \IndI \If $p^* = \bot$ \Then \Return $\mathit{OnlinePhase}^{S^{(n)}, V, G}(\mathit{prefix}, p, i, n, k, q, \delta)$ \\
  \IndI \Else $\mathit{prefix} := \mathit{prefix} \circ p^*$\\
  $ a^{(n)} := S^{(n)}(\mathit{prefix} \circ p)$ \\
  \Return $a_n$
\end{codeblock}
%
\begin{codeblock}
  \textbf{Algorithm:} $\mathit{OnlinePhase^{S^{(n)}, V, G}(\mathit{prefix}, p, i, n, k, q, \delta)}$
  \medskip \hrule
  \textbf{Oracle:} A solver algorithm $S^{(n)}$ for $P^{(n)}$, a puzzle--generation algorithm $G$ for $P$, a~verification algorithm $V$ for~$P$.\\
  \textbf{Input:} A $(v-1)$--tuple of bitstrings $\mathit{prefix}$, a bitstring $p \in \{0,1\}^{*}$, \\ parameters $v, n, k, q, \delta$.
  \medskip\hrule
  \Repeat $\Big\lceil\frac{6q \ln (6q)}{\delta^{n-i+1}}\Big\rceil$ times \\
  \IndI $((p_{i+1}, \dotsc, p_{n}),(c_{i+1}, \dots, c_n)) := G^{(n-i-1)}(1^k)$\\
  \IndI $a^{(n)} := S^{(n)}(\mathit{prefix}, p, p_{i+1}, \dotsc, p_n)$\\
  \IndI \If $\forall_{i+1 \leq j \leq n} V(p_j, c_j, a_j) = 1$ \Then \Return $a_i$\\
  \Return $\bot$
\end{codeblock}
%
\begin{codeblock}
  \textbf{Algorithm:} $\mathit{ExtendPrefix^{S^{(n)}, V, G}(prefix, i, n, k, q, \delta)}$
  \medskip \hrule
  \textbf{Oracle:} A solver algorithm $S^{(n)}$ for $P^{(n)}$, a puzzle--generation algorithm $G$ for $P$, a~verification algorithm $V$ for~$P$.\\
  \textbf{Input:} A $(i-1)$--tuple of puzzles $\mathit{prefix}$, parameters $i, n, k, q, \delta$.
  \medskip\hrule
  \Repeat $\Big\lceil \frac{6q}{\delta^{n-v+1}} \ln (\frac{18qn}{\delta}) \Big\rceil$ times \\
  \IndI $(p^*, c^*) := G(1^k) $\\
  \IndI $\bar{\nu}_i := \mathit{EstimateResSuccProb}^{G,V}(\mathit{prefix} \circ p^*, i, n, k, q, \delta)$\\
  \IndI \If $\bar{\nu}_i \geq \delta^{n-i}$ \Then \Return $p^*$ \\
  \Return $\bot$
\end{codeblock}
%
\begin{codeblock}
  \textbf{Algorithm:} $\mathit{EstimateResSuccProb}^{S^{(n)},V, G}(\mathit{prefix}, i, n, k, q, \delta)$
  \medskip \hrule
  \textbf{Oracle:} A solver algorithm for $P^{(n)}$, a verification algorithm $V$ for $P$, a~generation algorithm $G$ for~$P$\\
  \textbf{Input:} A $i$--tuple of puzzles $\mathit{prefix}$, parameters $i, n, k, q, \delta$.
  \medskip\hrule
  $successes := 0$ \\
  \Repeat $M := \Big\lceil \frac{84q^2}{\delta^{n-i}} \ln \Big(\frac{18qn \cdot N_i}{\delta} \Big) \Big\rceil$ times \\
  \IndI $((p_{i+1}, \dotsc, p_n), (c_{i+1}, \dotsc, c_n)) := G^{(n-i)}(1^k)$\\
  \IndI $a^{(n)} := A(\mathit{prefix}, p_{i+1}, \dotsc, p_{n})$\\
  \IndI \If $\forall_{i + 1\leq j \leq n} : V(p_j, c_j, a_j) = 1$ \Then $\mathit{successes := successes + 1}$ \\
  \Return $successes / M$
\end{codeblock}
%
%TODO: does this intuition works when $A$ is not deterministic i.e. cells then depends on the randomness of $A$.
A detailed proof of Theorem \ref{thm:wvp_chs} is presented in \cite{canetti2004hardness}.
We limit ourselves to providing the intuition why the CHS--solver transforms a good solver
for the $n$--wise direct product of $P$ to a good solver for $P$.

Let us consider the $n$-fold repetition of $P$, and for simplicity a deterministic solver $S^{(n)}$ for $P^{(n)} := (G^{(n)}, V^{(n)})$.
Furthermore, we write $p^{(n)}, c^{(n)}$ to denote the output of $G^{(n)}$.
We define a matrix $M$ as follows. The columns of $M$ are labeled with all possible bitstrings $p_1$
whereas the rows are labeled with all possible tuples $(p_2, \dotsc, p_n)$ output by algorithm $G^{(n)}$
executed with different randomness.
A cell of $M$ contains a binary $n$-tuple such that the $i$-th bit equals $1$ if and only if $V_i(p_i, c_i, a_i) = 1$ where
 $a^{(n)} := S^{(n)}(p^{(n)})$ and $p^{(n)}$ is a tuple of bitstring inferred by a column and a row of the cell.
We make the following observation.
%
\begin{observation}
\label{obs:wvp_matrix}
For a deterministic polynomial time algorithm $S^{(n)}$ that successfully solves the $n$--fold repetition of $P$ with probability at least $\delta^{n}$
the matrix $M$ defined as above has either a column with $\delta^{(n-1)}$ fractions of cells that are all one vectors, or
a conditional probability that a cell is of the form $1^n$ given that the last $(n-1)$ bits of the cell are equal 1 is at least $\delta$.
\end{observation}
%
We show, at least intuitively using Observation \ref{obs:wvp_matrix}, how the algorithm $\mathit{CHS\text{--}solver}$ can be used to solve a puzzle defined by $P$
with substantial probability given oracle access to $S^{(n)}$ for $P^{(n)}$.
The algorithm starts with the first position and tries to fix a bitstring $p^*$ on this position such that the success probability of $S^{(n)}$ on the remaining $(n-1)$
position is at least $\delta^{(n-1)}$. If it is possible to find $p^*$ such that this condition is satisfied, then we fix $p^*$
on this position and repeat the whole procedure again in the consecutive iteration for the next position.
If $\mathit{CHS\text{--}solver}$ fails to find a bitstring $p^*$, then we assume that there is no column of $M$ that contains a $\delta^{(n-1)}$ fraction
of cells that are of the form $1^n$. We use Observation~\ref{obs:wvp_matrix} to conclude that the conditional probability of
solving the first puzzle given that all puzzles on the remaining position are solved successfully is at least~$\delta$.
We place the input puzzle $p$ on this position and note that all remaining puzzles are generated by $\mathit{CHS\text{--}solver}$.
Thus, it is possible to efficiently verify whether these puzzles are successful solved by $S^{(n)}$.

Obviously, the algorithm $\mathit{CHS\text{--}solver}$ can still fail. First, it may happen that it does not find a column
with a high fraction of puzzles that are solved successfully, although such a column exists.
Secondly, we cannot exclude a situation where no such column exists, but the algorithm fails to find a cell such that last $(n\!-\!1)$ bits are 1.
Finally, it is also possible that an estimate returned by $\mathit{EstimateResSuccProb}$ is incorrect.

It is possible to show that all these events happen with small probability.
Therefore, at least intuitively we see that the algorithm $\mathit{CHS\text{--}solver}$
solves a single WVP puzzle successfully with probability at least $\delta(1\!-\!\frac{1}{q})$ almost surely.

In Chapter \ref{ch:main_result} we study a more general class of puzzles that are not only weakly verifiable but also dynamic and interactive.
Furthermore, we allow a more general situation where a solver successfully solves the $n$-fold repetition of puzzles\footnote{Actually,
in Chapter \ref{ch:main_result} we define the $k$-wise repetition of puzzles following the terminology used in \cite{Dodis:2009:SAI:1530441.1530450}
which is equivalent to the $n$-fold repetition of puzzles.}
although it succeeds only on some coordinates of the $n$-fold repetition of $P$.
It turns out that it is possible to use a similar technique of fixing puzzles on consecutive positions of the $n$-fold repetition of
puzzles to prove the hardness amplification in this more general setting.
%
\section{Dynamic Weakly Verifiable Puzzles}
\label{section:dijk}
Some of the cryptographic constructions presented in Section~\ref{section:wvp_examples}
are not only weakly verifiable but also dynamic (MAC and SIG). This type of puzzles are defined and studied in \cite{Dodis:2009:SAI:1530441.1530450}.
We give a short overview of this work, state the definition of a \textit{dynamic weakly verifiable puzzle} that closely follows
the one included in \cite{Dodis:2009:SAI:1530441.1530450}. Finally, we provide intuition for the proof of the hardness amplification of DWVP
included in \cite{Dodis:2009:SAI:1530441.1530450}.

\subsection{The definition}
\begin{definition}[Dynamic Weakly Verifiable Puzzle.]
  \label{def:dwvp_dodis}
  A \textnormal{dynamic weakly verifiable puzzle} (DWVP) is defined by a distribution $\cD$ on pairs $(x, \alpha)$
  where $\alpha \in \{0,1\}^{*}$ is an advice used to generate and evaluate responses and $x \in \{0,1\}^{*}$ is
  a bitstring taken as input by the solver.
  Furthermore, we consider a set $\cQ$ and a probabilistic polynomial time computable relation $R$ such that
  $R(\alpha, q, r) = 1$ if and only if $r$ is a correct answer to $q \in \cQ$ on the set of puzzle determined by $\alpha$.
  Finally, let $H(\alpha, q)$ be a probabilistic polynomial time computable \textnormal{hint} relation.

  A solver $S$ takes as input $x$ and can ask hint queries on $q \in \cQ$ which are answered using $H(\alpha, q)$ and verification
  queries of the form $(q,r)$ answered by means of $R(\alpha, q, r)$.
  We say that $S$ succeeds if and only if it makes a verification query on $(q,r)$ such that
  $R(\alpha,q,r) = 1$ and it
  has not previously asked for a hint query on this $q$. We write $P := (\cD, R, H)$ to denote a DWVP with a distribution
  $\cD$ of pairs $(x, \alpha)$, and $R$, $H$ being a verification and hint relations respectively.
\end{definition}
%
We show now how the above definition is generalized by Definition \ref{def:dwvp}.
First, instead of considering a distribution on pairs $(x,\alpha)$ in Definition \ref{def:dwvp}
we use a probabilistic problem poser that outputs circuits $\Gamma_H$ and $\Gamma_V$ that corresponds to hint
and verification relations respectively.
Furthermore, the problem poser may interact in the first phase with the problem solver.
In particular, the problem poser can send a bitstring $x$ as a message in the first phase.
Thus, Definition \ref{def:dwvp} captures a more general case where the distribution of
puzzles is defined by both the problem poser and the problem solver.

We define the \textit{$n$-wise direct product of DWVPs} which is conceptually similar to the $n$-fold repetition of WVPs.
%
\begin{definition}[$n$-wise direct product of DWVPs]
For a dynamic weakly verifiable puzzle $P~:=~(\cD, R, H)$ we define the $n$-wise direct product of $P$
as a DWVP with a distribution $\cD^{(n)}$ on tuples $(x_1, \alpha_1), \dotsc, (x_n, \alpha_n)$.
Furthermore, the hint relation is defined by $H^{(n)}(q, \alpha_1, \dotsc, \alpha_n) := (H(\alpha_1, q), \dotsc, H(\alpha_n, q))$ and
the verification relation $R^{(n)}(\alpha_1, \dotsc, \alpha_n, r_1, \dotsc, r_n, q)$ evaluates to $1$ if and only if
for $1\!\leq\!i\!\leq\!n$ at least $n - (1 - \gamma)\delta n$ is such that $R(\alpha_i, q, r_i)~=~1$ where $0~\leq~\gamma,\delta~\leq~1$.
%
We write $P^{(n)} := (D^{(n)}, H^{(n)}, R^{(n)})$ to denote the $n$-wise direct product of $P := (D,H,R)$.
%
\end{definition}

In contrast to the $n$-fold repetition of puzzles defined in the previous section, here we
require the solver to succeed only on a fraction of puzzles.

Dynamic weakly verifiable puzzles generalize a games of breaking security of message authentication codes and public signature schemes.
In case of MAC the adversary takes $x$ which is an empty string. For the public signature schemes $x$ is the public key.

We write $(\cH_{\mathit{hint}}, \cV_{\mathit{verif}}) \leftarrow S(x; \delta)$
to denote the execution of a solver $S$ with input $x \in \{0,1\}^{*}$ and using randomness $\delta \in \{0,1\}^{*}$.
Furthermore, $\cH_{hint}$ is the set of all hint queries asked by $S$ and $\cV_{verif}$ is
a set of all pairs $(q,a)$ of verification queries asked in the execution of $S$.

With no loss of generality we make the assumption that the solver does not make
hint queries on the successful verification queries.
We define the \textit{success probability} of a solver $S$ for $P := (G,V)$ as
\begin{align*}
  \underset{\substack{\delta \in \{0,1\}^{*} \\(x,\alpha) \leftarrow \cD \\ (\cH_{hint}, \cV_{verif}) \leftarrow S(x,\delta))}}
  {\Pr}\big[\exists (q,a) \in \cV_{verif} : q \notin \cH_{hint} \land V(q,a) := 1 \big]
\end{align*}

\subsection{The hardness amplification theorem}
\begin{theorem}\textbf{(Hardness amplification for dynamic weakly verifiable puzzles).}
\label{lemma:dwvp}
Let $S^{(n)}$ be a probabilistic algorithm for $P^{(n)}$ that succeeds with
probability at least $\epsilon$, where $\epsilon \geq (800/\gamma\delta) \cdot (h+v) \cdot e^{-\gamma^2\delta n/40}$, and $h$ and $v$
denote the number of hint and verification queries asked by $S^{(n)}$ respectively.
Then there exists a probabilistic algorithm $S$ that succeeds in solving $P$ with probability at least
$1-\delta$ making $O(h(h+v)/\epsilon) \cdot \log(1/\gamma\delta)$ hint queries and at most one verification query.
Furthermore, the running time is $\mathit{poly}(h,v,\frac{1}{\epsilon}, t, \omega, \log(1/\gamma\delta))$ where
$\omega$ is time needed to ask a single hint query.
\end{theorem}

It is worth seeing why the approach presented in the previous section that works well for the $n$-fold repetition of WVP
cannot be applied for the $k$-wise direct product of DWVP (moving aside for a moment the issue of solving only a fraction of puzzle successfully).
For DWVP the algorithm $\mathit{CHS\text{--}solver}$ breaks in the $\mathit{OnlinePhase}$ where
the solver $S^{(n)}$ can be called multiple times.
It is possible that in one of these runs $S^{(n)}$ asks a hint query on $q$
for which in one of the later runs a verification query $(q,r)$ is asked
for which algorithm would return an answer for the input puzzle
(in other words the condition $\forall_{v+1 \leq i \leq n} V(p_i, c_i, a_i) = 1$ is satisfied).
However, the fact that a hint query on this $q$ has been asked makes it impossible to ask a successful verification query on this $q$.
Thus, we can not dismiss a situation where the success probability of $S^{(n)}$ decreases with the number of iterations.

The solution proposed in \cite{Dodis:2009:SAI:1530441.1530450} is to partition the set $\cQ$ into a set of \textit{attacking queries} $\cQ_{\mathit{attack}}$
and a set of \textit{advice queries} $\cQ_{\mathit{adv}}$. The idea is to allow a solver for the $n$-wise direct product to ask hint
queries only on $q \in \cQ_{\mathit{adv}}$, and to halt the execution whenever a hint query is asked on $q \in \cQ_{\mathit{attack}}$.

It is possible, for a solver $S$ that asks at most $h$ hint queries and $v$ verification queries,
to find a function $\cQ \rightarrow \{0,1,\dotsc 2(h+v)-1\}$ such that the success probability of $S$ with respect to
$\cQ_{\mathit{attack}}$ and $\cQ_{\mathit{adv}}$ is multiplied by $\frac{1}{8(h+v)}$.
If $h$ and $v$ are not too big, then the success probability of $S$ can be still substantial.
More formally, for a function $\hash:\cQ \rightarrow \{0,1,\dotsc, 2(h+v)\!-\!1 \}$
we define $\cQ_{\mathit{attack}} := \{q \in \cQ : \hash(q) = 0 \}$ and $\cQ_{adv} := \{q \in \cQ: \hash(q) \neq 0\}$

In \cite{Dodis:2009:SAI:1530441.1530450} the following lemma is proved.
\begin{lemma}
  \label{lemma:hash_function_previous}
Let $S$ be a solver for DWVP which success probability is at least $\delta$, the running time is at most $t$,
and the number of hint and verification queries is at most $h$ and $v$ respectively.
There exists a probabilistic algorithm that runs in time $poly(h,v,\frac{1}{\delta},t)$
that outputs a function $\hash : \cQ \rightarrow \{0,1, \dotsc, 2(h+v)-1\}$
that partitions $\cQ$ to $\cQ_{attack}$ and $\cQ_{adv}$ such that
with probability at least $\frac{\delta}{8(h+v)}$ the first successful verification query $(q',a)$ asked by $S$ is such that $q' \in \cQ_{attack}$
and all previous hint and verification queries has been asked on $q \in \cQ_{adv}$.
\end{lemma}
A function $\hash$ can be found by using a natural sampling technique.
We follow exactly the same approach of the partitioning the domain in the main proof of this Thesis in Section \ref{st:domain_partition}.

Let $H_{\alpha}(q)$ denote a polynomial time probabilistic algorithm that takes as input $q$,
has hard-coded $\alpha$ and outputs $H(\alpha, q)$.
Similarly, we use $R_{\alpha}(q,r)$ to denote a polynomial time probabilistic algorithm that computes relations
$R(\alpha, q, r)$ and has hard-coded bitstring $\alpha$.
The following algorithm is used in \cite{Dodis:2009:SAI:1530441.1530450} in the proof of Lemma \ref{lemma:dwvp}.
It gains oracle access to $R_{\alpha}$ and $H_{\alpha}$ as well as a function $\hash$ from Lemma \ref{lemma:hash_function_previous}.
%
\begin{codeblock}
  \textbf{Algorithm:} $\mathit{DWVP\text{--}solver}^{S^{(n)}, \hash, H_{\alpha}^{(n)}, R_{\alpha}^{(n)}}(x)$
  \medskip
  \hrule
  \textbf{Oracle:}  A solver $S^{(n)}$ for $P^{(n)}$, a function $hash : Q \rightarrow \{0,1, \dotsc, 2(h+v)-1\}$.\\
  \textbf{Input:} A bistring $x \in \{0,1\}^{*}$.
  \medskip\hrule
  \Repeat at most $O(\frac{h+v}{\epsilon} \cdot \log(\frac{1}{\gamma\delta}))$ times \\
  \IndI Let $i \xleftarrow{\$} \{1, \dotsc, n\}$ be a position for $x$.\\
  \IndI Generate $(x_1, \alpha_1), \dotsc, (x_{i-1}, \alpha_{i-1}), (x_{i+1}, \alpha_{i+1}), \dotsc, (x_n, \alpha_n)$ \\
  \IndI using $(n-1)$ calls to $P$ each time with fresh randomness.\\
  \IndI \Run $S^{(n)}(x_1, \dotsc, x_{i-1}, x, x_{i+1}, \dotsc, x_n)$\\
  \IndII \If $S^{(n)}$ asks a hint query on $q$ \Then \\
  \IndIII \If $hash(q) \neq 0$ \Then abort current run of $S^{(n)}$\\
  \IndIII Ask a verification query $r := H(q)$\\
  \IndIII Let $(r_1, \dotsc, r_{i-1}, r_{i+1}, \dotsc, r_{n})$ be hints for query $q$ for puzzle\\
  \IndIII sets $(x_1, \dotsc, x_{i-1}, x_{i+1}, x_n)$\\
  \IndIII Answer the hint query of $S^{(n)}$ using $(r_1, \dots, r_{i-1}, r, r_{i+1}, r_n)$\\
  \IndII \If $S^{(n)}$ asks a verification query $(q, r_1, \dots, r_n)$ \Then \\
  \IndIII \If $hash(q) = 0$ \Then answer the query with $0$\\
  \IndIII Let $m := |j: V(q,r_j) = 1, j \neq i|$\\
  \IndIII \If $m \geq n - n(1-\gamma)\delta$ \Then \\
  \IndIIII make a verification query $(q, r_i)$ and halt.\\
  \IndIII \Else with probability $\rho^{m - n(1-\gamma)\delta}$ ask a verification query \\
  \IndIIII $(q, r_i)$ and halt. \\
  \IndIII Halt the current run of $S^{(n)}$ and go to the next iteration.\\
  \Return $\bot$
\end{codeblock}

% \begin{todo}
%   \textbf{TODO:} explain that hints can be auto generated.
% \end{todo}
%The above algorithm substantially differs from the one used in \cite{canetti2004hardness}.
In the above algorithm we execute multiple times a solver $S^{(n)}$ for the $k$-wise direct product of DWVPs.
In each iteration the position for $x \in \{0,1\}^{*}$ is chosen uniformly at random.
The remaining $(n-1)$ puzzles are generated by the algorithm, thus it is possible to answer
all hint and verification queries for these puzzles.
We use a function $\hash$ to partition the query domain and assume that $\hash$ is such
that the success probability of $S^{(n)}$ with respect to $\hash$ is at least $\frac{\delta}{8(h+v)}$.
We check on which $q$ the solver $S^{(n)}$ asks hint and verification queries.
If a hint query is asked on $q$ such that $hash(q) = 0$ then the execution of $S^{(n)}$
is aborted and we go to the next iteration. This way we make sure that the algorithm
never asks a hint query that could prevent a verification query from succeeding.

%TODO unfold this a bit more
If a verification query is asked on $q$ such that $hash(q) \neq 0$ we answer such a verification
query with $0$.

Finally, in case when $S^{(n)}$ asks a verification query using index $q$ such that $hash(q) = 0$, then
we use a soft decision system to decide whether to ask a verification query.
The idea is that if there are many puzzles among the ones generated by the algorithm that are solved successfully,
then it is likely that also the input puzzle is solved successfully.
We discount $\gamma\delta n$ to take into account that not all puzzles have to be solved successfully.
The detail calculations provided in \cite{Dodis:2009:SAI:1530441.1530450} show that this approach
yields a demanded result. We do not give a more detail description of the proof of \cite{Dodis:2009:SAI:1530441.1530450} as
in Chapter \ref{ch:main_result}, except the domain partitioning, we use a different technique.

In case of weakly verifiable primitives like CAPTCHAs we assume that most people have at least slightly higher probability of solving
these kind of puzzles than the best computer programs. Still, it may happen that humans do not solve all puzzles.
This is a motivation to introduce a threshold function such that on average solutions of humans are treated as solved successfully
but the ones of computer programs on average are classified as not successful.
This motivates a study of the situations where only a fraction of puzzles is solved successfully.

In Chapter \ref{ch:main_result} we consider a weakly verifiable puzzles that are not only dynamic but also interactive.
We use a very similar technique to partition domain $Q$ into advice and hint queries as presented in \cite{Dodis:2009:SAI:1530441.1530450}.
Instead of the requirement to succeed only on a fraction of puzzles we consider an arbitrary, monotone function $g : \{0,1\}^{n} \rightarrow \{0,1\}$
that determines on which coordinates the solver has to succeed in order to successfully solve the $n$-wise direct product of puzzles.

To show the hardness amplification for the $n$-wise direct product with the domain partitioned we use
the approach similar to the one presented in Section~\ref{subsec:chs}. Namely, we try to find a good position for the input puzzle instead of
choosing the position uniformly on random as in \cite{Dodis:2009:SAI:1530441.1530450}.

\section{Interactive Weakly Verifiable Puzzles}
\label{section:iwvp}
% \begin{todo}
%   \textbf{TODO:} Justify why you do not give a more detail description of the
%   algorithm as in the previous sections . \\
%   \textbf{TODO:} Explain in detail what is in your work and what is here.
%   What are my contributions.
% \end{todo}
%
The hardness amplification of interactive weakly verifiable puzzles has been studied by T.Holenstein and G.Schoenebeck in \cite{DBLP:journals/corr/abs-1002-3534}.
We will give now an overview of this work and compare it with our approach.

\subsection{The definition}
The following definition of an \textit{interactive weakly verifiable puzzle} closely follow the one from \cite{DBLP:journals/corr/abs-1002-3534}.
\begin{definition}
An \textit{interactive weakly verifiable puzzle} is defined by a protocol given by two probabilistic algorithms $P$ and $S$.
The algorithm $P$ is called the problem poser and produces as output a verification circuit $\Gamma$.
The algorithm $S$ called the problem solver produces no output.
Furthermore, the \textnormal{success probability} of the algorithm $S$ in solving an interactive weakly verifiable puzzle defined by $(P,S)$ is:
\begin{align*}
  \underset{\substack{\rho, \pi \\ \Gamma^{(g)} := \langle P(\rho), S(\pi) \rangle_{P}}}{\Pr}\Big[\Gamma^{(g)}(\langle P(\rho),S(\pi) \rangle_{S}) = 1 \Big].
\end{align*}
\end{definition}
We are intrested in the hardness amplification of interactive weakly verifiable puzzles. Thus, similarly as in the previous sections
we define the $k$-wise direct product of puzzles.
\begin{definition}\textbf{($\boldsymbol{k}$-wise direct product of interactive weakly verifiable puzzles)}
Let $g: \{0,1\}^{k} \rightarrow \{0,1\}$ be a monotone function and $(P,S)$ be a fixed interactive weakly verifiable puzzle.
The $k$-wise direct product of $(P,S)$ defined by $(P^{(g)}, S^{(g)})$ is an interactive weakly verifiable puzzles in which the sender and the receiver
sequentially interact in $k$ rounds where in each round $(P,S)$ is used to generate an instance of interactive weakly verifiable puzzle.
As the result circuits $\Gamma^{(1)}, \dotsc, \Gamma^{(k)}$ for $P$ are generated.
Finally, $P^{(g)}$ outputs the circuit $\Gamma^{(g)}(y_1, \dotsc, y_k) := g(\Gamma^{(1)}(y_1), \dotsc, \Gamma^{(k)}(y_k))$.
\end{definition}

Similarly as in Definition \ref{def:dwvp} the puzzles considered in \cite{DBLP:journals/corr/abs-1002-3534} are interactive.
Furthermore, a monotone binary function is used to determine whether the $k$-wise repetition
has been successfully solved. Unlike, puzzles in Definition \ref{def:dwvp}, the puzzles studied by T.Holenstein and G.Schoenebeck
are non-dynamic. Thus, only a verification circuit $\Gamma$ is generated and no hint circuit is ever used.

\subsection{The hardness amplification theorem}
The following hardness amplification theorem is proved in \cite{DBLP:journals/corr/abs-1002-3534}.
\begin{theorem}
There exists an algorithm $\mathit{Gen}(C,g,\epsilon, \delta, n)$ which takes as input a solver circuit $C$ for the $k$-wise
direct product of $P$, a monotone function $g: \{0,1\}^{*} \rightarrow \{0,1\}$, and parameters $\epsilon,\delta,n$.
The algorithm $\mathit{Gen}$ outputs a solver circuit $D$ for $P$ such that the following holds.
If $C$ is such that
\begin{align*}
\Pr\Big[\Gamma^{(g)}(\langle P^{(g)}, C \rangle_C) = 1\Big] \geq \Pr_{u \leftarrow \mu_{\delta}^{(k)}} \Big[ g(u) = 1 \Big] + \epsilon,
\end{align*}
then, $D$ satisfies almost surely,
\begin{align*}
  \Pr\Big[ \Gamma(\langle P, D\rangle_{D}) = 1\Big] \geq \delta + \frac{\epsilon}{6k}.
\end{align*}
Additionally, $\mathit{Gen}$ and $D$ only require oracle access to $g$ and $C$.
Furthermore, $\mathit{Size}(D) \leq \mathit{Size}(C) \cdot \frac{6k}{\epsilon} \log(\frac{6k}{\epsilon})$,
and $\Time (\mathit{Gen}) = \poly(k, \frac{1}{\epsilon}, n)$ with oracle calls.
\end{theorem}

First, we notice that the above definition does not impose any restrictions on the time complexity of the poser and the solver.
We consider a general approach where $\mathit{Gen}$ is used to define a polynomial time reduction between a solver for the $k$-wise
direct product of puzzles to a solver for a single puzzle.
Furthermore, in the previous sections we considered solvers for the $k$-wise direct product that were compared with the algorithms that either
solves all puzzles (\cite{canetti2004hardness}) or allowed a fraction of puzzles to be solved incorrectly (\cite{Dodis:2009:SAI:1530441.1530450}).
In the above definition a more general case is considered where we use a binary monotone function $g$.
More precisely we are interested functions that are binary monotonously non-decreasing.

The proof technique used by T.Holenstein and G.Schoenebeck is similar to the one presented in Section \ref{subsec:chs}.
In chapter \ref{ch:main_result} we use very similar approach and fix puzzles on consecutive coordinates of the $n$-wise direct product.

% \begin{todo}
%   \textbf{TODO:} Compare to the work of CHS i.e. what we use there to compare the puzzles
% \end{todo}

% In order to estimate how much better a solver circuit $C$ for the $n$-wise direct product performs when
% a puzzle on the first position is fixed a notion of a surplus $S_{\pi^*, b}$ is introduced:
% \begin{align*}
% S_{\pi^*, b} := \Pr_{\pi^{(k)}} [ c \in \cG_b | \pi_1 = \pi^* ] - \Pr_{u \leftarrow \mu_{\delta}^{k}} [u \in \cG_b],
% \end{align*}
% which intuitively tells us how much better a solver $C$ performs when a first puzzle is always solved correctly (case when $b = 1$)
% or is always solved incorrectly (when $b = 0$).
% Now we observe the following fact. If there exists a puzzle which is fixed on the first position for which the surplus is bigger than
% $(1 - \frac{1}{k})\epsilon$ then we can fixed a this first puzzle and inductively solve the problem for the $(k-1)$-direct product of puzzles.
% \begin{todo}
%   \textbf{TODO:} what do it mean
% \end{todo}
% On the other hand, if we there is no such puzzle to fix on the first position it means that when we fix the first bit of $g$ then
% the performance between the solver $C$ and an algorithm that solves puzzle on each position independently with probability $\delta$
% is similar. However, we know that when the first bit of a function $g$ is not fixed then the solver $C$ is better.
% Thus, we draw a conclusion that the puzzle on the first position has to be solved unusually often.

% In a case it would be possible to fix all $(k-1)$ puzzles except the last one, the proof become trivial as we know that a function
% $g$ with the first $k-1$ bits fixed is either the identity or a constant function.
% %TODO write why it is true in this case

% Thus, it is enough to show that if it is not possible to find an estimate that is low then
% if we place an input puzzle on this position and we can find remaining $k-1$ puzzle such that
% $c \in \cG_1 \setminus \cG_0$ then this puzzle is solved with substantial probability.
% The whole proof is given in \cite{DBLP:journals/corr/abs-1002-3534}, and requires some probability manipulations.

% %cite tell more what is used in our proof which technique do we use.
% Our proof of the hardness amplification for dynamic interactive weakly verifiable puzzles closely follows the one given in \cite{DBLP:journals/corr/abs-1002-3534}.
% \begin{todo}
%   \textbf{TODO:} Why do we consider fixing 0/1 on the first position
%   \textbf{TODO:} How the technique is generalized to approach of CHS \\
%   \textbf{TODO:} Explain why we compare to such a probability i.e. why we consider with $\mu$ \\
%   \textbf{TODO:} Why the requirement for $g$ being a monotone function is interesting \\
%   \textbf{TODO:} Give the intuition behind the proof. \\
%   \textbf{TODO:} Give a proof under the simplified assumptions? \\
%   1) The algorithm always output an answer \\
%   2) For every pi the surpluses $S_{\pi^*, 0}$ and $S_{\pi^*, 1}$ re less than $(1-\frac{1}{k})\epsilon$.\\
% \end{todo}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
