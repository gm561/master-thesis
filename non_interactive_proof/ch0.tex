\begin{definition} {\textbf{Dynamic weakly verifiable puzzle (non interactive version)}}\\
  A dynamic weakly verifiable puzzle (DWVP) is defined by a probabilistic algorithm $P(\pi)$,
  called a problem poser, that takes as input chosen uniformly at random bitstring $\pi \in \{0,1\}^l$,
  and produces circuits $\Gamma_{V}$, $\Gamma_{H}$ and a puzzle $x \in \{0,1\}^{*}$.
  The circuit $\Gamma_{V}$ takes as its input $q \in Q$ and an answer $y$.
  If $\Gamma_V(q,y) = 1$ then $y$ is a correct solution of puzzle $x$ for $q$.
  The circuit $\Gamma_H$ on input $q$ provides a hint such that $\Gamma_V(q,\Gamma_H(q)) = 1$.
  The algorithm $S$, called a solver, has oracle access to $\Gamma_V$ and $\Gamma_H$.
  The calls of $S$ to $\Gamma_V$ are called verification queries and the calls to $\Gamma_H$ are hint queries.
  The solver $S$ can ask at most $h$ hint queries, $v$ verification queries, and successfully solves a DWVP if and only if
  it makes a verification query $(q,y)$ such that $\Gamma_V(q,y) = 1$, when it has not previously asked for a hint query on this $q$.
\end{definition}
%
%
\begin{definition}{\textbf{$k$-wise direct product of dynamic weakly verifiable puzzles}}\\
Let $g: \{0,1\}^{k} \rightarrow \{0,1\}$ be a monotone function, and $P^{(1)}$ a probabilistic algorithm used to generate an instance of DWVP.
A $k$-wise direct product of dynamic weakly verifiable puzzles is defined by a probabilistic algorithm $P^{(g)}\left(\pi_1, \dots, \pi_k \right)$,
where $(\pi_1, \dots, \pi_k) \in \{0,1\}^{k \cdot l}$ are chosen uniformly at random.
$P^{(g)}\left(\pi_1, \dots, \pi_k \right)$ sequentially generates $k$ independent instances of dynamic weakly verifiable puzzles,
where in the $i$-th round $P^{(g)}$ runs $P^{(1)}(\pi_i)$ and obtains $(x_i, \Gamma_V^{(i)}, \Gamma_H^{(i)} )$.
Finally, $P^{(g)}$ outputs a verification circuit
\begin{align*}
  \Gamma_V^{(g)} (q, y_1, \dots, y_k) := g(\Gamma_V^{(1)}(q, y_1), \dots, \Gamma_V^{(k)}(q, y_k)),
\end{align*}
a hint circuit
\begin{align*}
  \Gamma_H^{(k)} (q) := (\Gamma_H^{(1)}(q), \dots, \Gamma_H^{(k)}(q)),
\end{align*}
and a puzzle $x^{(k)} := (x_1, \dots, x_k)$.
\\
The probabilistic algorithm $S$, called a solver, has oracle access to $\Gamma_V^{(g)}, \Gamma_H^{(k)}$.
The solver $S$ can ask at most $v$ verification queries to $\Gamma_V^{(g)}$, $h$ hint queries to $\Gamma_H^{(k)}$ and successfully solves the puzzle $x^{(k)}$
if and only if it asks a verification query $(q, y_1, \dots, y_k)$ such that $\Gamma_V^{(g)}(q, y_1, \dots, y_k) = 1$, and it has not previously asked for a hint query on this $q$.
\end{definition}
%
%
\begin{codeblock}
  \textbf{Experiment $A^{P^{(1)}, D}(\pi)$} \\
  Solving a dynamic weakly verifiable puzzle.
  \medskip

  \hrule

  \medskip

  \textbf{Oracle:} A problem poser $P$ for DWVP. \\
                   \IndII A solver circuit $D^{(\cdot,\cdot)}$ for DWVP. \\
  \textbf{Input:}  A bitstring $\pi \in \{0,1\}^{l}$.\\

  \medskip\hrule\medskip

  $(x, \Gamma_V, \Gamma_H) := P^{(1)}(\pi)$ \\
  Run $D^{(\Gamma_V,\Gamma_H)}(x)$ \\
  \IndI Let $Q_{Solved} := \{q: \text{$D^{\Gamma_H, \Gamma_V}(x)$ asked a verification query on $(q,y)$ and $\Gamma_V(q, y) = 1$} \}$\\
  \IndI Let $Q_{Hint} := \{q: \text{$D^{\Gamma_H, \Gamma_V}(x)$ asked a hint query on q} \}$\\
  \textbf{If} $\exists q \in Q_{solved} : q \notin Q_{Hint}$\\
  \IndI \textbf{return} $1$\\
  \textbf{else}\\
  \IndI \textbf{return} $0$\\
\end{codeblock}
%
%
\begin{codeblock}
  \textbf{Experiment $B^{P^{(g)}, C^{(\cdot,\cdot)}}(\pi_1, \dots, \pi_k)$} \\
  Solving k-wise direct product of dynamic weakly verifiable puzzles.
  \medskip

  \hrule

  \medskip

  \textbf{Oracle:} A problem poser for $k$-wise direct product $P^{(g)}$. \\
                   \IndII A solver circuit for $k$-wise direct product $C^{(\cdot,\cdot)}$.\\
  \textbf{Input:} Random bitstring $\{\pi_1, \dots, \pi_k\} \in \{0,1\}^{kl}$.

  \medskip\hrule\medskip

  $(x^{(k)}, \Gamma_V^{(g)}, \Gamma_H^{(g)}) := P^{(g)}(\pi^{(k)})$ \\
  Run $C^{(\Gamma_V^{(g)}, \Gamma_H^{(k)})}(x^{(k)})$\\
  \IndI Let $Q_{Solved} := \{q: \text{$D^{\Gamma_V^{(g)}, \Gamma_H^{(k)}}(x^{(k)})$ asked a verification query on $(q, y^{(k)})$ and $\Gamma_V(q, y^{(k)}) = 1$} \}$\\
  \IndI Let $Q_{Hint} := \{q: \text{$D^{\Gamma_V^{(g)}, \Gamma_H^{(k)}}(x^{(k)})$ asked a hint query on q} \}$\\
  \textbf{If} $q \notin Q_{Hint}$\\
  \IndI \textbf{return} $1$\\
  \textbf{else}\\
  \IndI \textbf{return} $0$\\

\end{codeblock}
%
%
\begin{theorem}{\textbf{Security amplification of a dynamic weakly verifiable puzzle.}}\\
  Fix a problem poser $P^{(1)}$.
  There exists an algorithm $Gen(C, g, \varepsilon, \delta, n, v, h)$ which takes as input a circuit $C$, a monotone function $g$, parameters
  $\varepsilon, \delta$, a security parameter $n$, number of verification $v$, and hint $h$ queries asked by $C$, and outputs a circuit $D$
  such that following holds: \\
  If $C$ is such that \\
  \begin{align*}
    \underset{(\pi_1, \dots, \pi_k) \in \{0,1\}^{lk}}{\Pr}[A^{P^{(g)}, C}(\pi_1, \dots, \pi_k) = 1] \geq \underset{\mu \leftarrow \mu_\delta^k}{\Pr}[g(\mu) = 1] + \varepsilon
  \end{align*}
  then $D$ satisfies almost surely
  \begin{align*}
    \underset{\pi \in \{0,1\}^{l}}{\Pr}[B^{P^{(1)},D}(\pi) = 1] \geq (\delta + \frac{\varepsilon}{6k})
  \end{align*}
  and $Size(D) \leq Size(C)\frac{6k}{\varepsilon}$ and $Time(Gen) = poly(k, \frac{1}{\varepsilon}, n, v, h)$.
\end{theorem}
%
%
%
% TODO define puzzle and probabilities using x^{(k)}
%
\begin{codeblock}
  \textbf{Experiment $E^{P^{(g)}, C^{(.)(.)}, Hash}(\pi_1, \dots, \pi_k)$} \\
  Solving $k$-wise direct product with respect to the set $P_{hash}$
  \medskip

  \hrule

  \medskip
  \textbf{Oracle:} Problem poser for k-wise direct product $P^{(g)}$ \\
  \IndI Solver circuit $C^{(.)(.)}$ with oracle access to hint and verification circuits \\
  \IndI Function $Hash: Q \leftarrow \{0, \dots, 2(h+v) - 1\}$\\
  \textbf{Input:} Random bitstring $(\pi_1, \dots, \pi_k) \in \{0,1\}^{lk}$\\

  \medskip\hrule\medskip

  $\pi^{(k)} := \left(\pi_1, \dots, \pi_k \right)$\\
  $(x^{k}, \Gamma_V^{(g)}, \Gamma_H^{(g)}) := P^{(g)}(\pi^{k})$\\
  Run $C^{\Gamma_V^{(g)}, \Gamma_H^{(g)}} (x^{(k)})$ \\
  \IndI Let $(q_j,y_j^{(k)})$ be the first successful verification query if $C^{\Gamma_V^{(g)}, \Gamma_H^{(g)}}$ succeeds or \\
  \IndI an arbitrary verification query when it fails.\\

  \textbf{If} $(\forall i < j :  Hash(q_i) \neq 0 )$ and $( Hash(q_j) = 1 \land \Gamma_V^{(g)}(q_j, y_j^{(k)}) = 1)$ \\
  \IndI \textbf{return} 1\\
  \textbf{else}\\
  \IndI \textbf{return} 0\\
\end{codeblock}
% Then canonical success probability of $C$ in a random experiment $A^{P^{(g)}, C, Hash}(\pi_1, \dots, \pi_k)$ is \\
% $\underset{(\pi_1, \dots, \pi_k)}{\Pr}[A^{P^{(g)}, C, Hash}(\pi_1, \dots, \pi_k)]$.
%
% TODO: circuits or algorithms
% TODO: size of circuits?
% TODO: need def. of canonical success and P_hash
% TODO: number of calls to oracle circuit C
%
\begin{lemma} \textbf{Success probability with respect to hash function.} \\
For a fixed $P^{(g)}$ let $C$ succeed in solving the $k$-wise direct product of DWVP produced by $P^{(g)}$
with probability $\epsilon$ making $h$ hint and $v$ verification queries.
There exists a probabilistic algorithm, with oracle access to $C$, that runs in time $O((h+v)^4/\varepsilon^4)$
and with high probability outputs a function $Hash: Q \rightarrow \{0, \dots, 2(h+v)-1\}$ such that success probability of
$C$ in random experiment $E$ with respect to the set $P_{Hash}$ is at least $\frac{\varepsilon}{8(h+v)}$.
\end{lemma}
%
% Proof of existence of hash function with required properties
%
\begin{proof}
Let $\cH$ be a family of pairwise independent hash functions $hash : Q \rightarrow \{0,1, \dots,2(h+v)-1\}$.
By pairwise independence property of $\cH$ we know that for all $i \neq j \in \{1, \dots, (h+v)\}$ and $k,l \in \{0,1,\dots,2(h+v)-1\}$
we have the following property
\begin{align}
  \label{eq:hash_pr}
 \forall q_i,q_j \in Q : \underset{\textit{hash} \leftarrow \cH}{\Pr}[hash(q_i) = k \mid hash(q_j) = l] = \underset{\textit{hash} \leftarrow \cH}{\Pr}[hash(q_i) = k] = \frac{1}{2(h+v)}
\end{align}
For a fixed $(\pi_1, \dots, \pi_k)$ we define an event, denoted by $X$, that $hash(q_j) = 0$ and for every query $q_i$ asked before $j$ $hash(q_i) \neq 0$.
We have
\begin{align*}
  \underset{\textit{hash} \leftarrow \cH}{\Pr}[X] &= \underset{\textit{hash} \leftarrow \cH}{\Pr}[hash(q_j) = 0 \land \forall i < j : hash(q_i) \neq 0] \\
  &=\underset{\textit{hash} \leftarrow \cH}{\Pr}[\forall i < j : hash(q_i) \neq 0 \mid hash(q_j) = 0] \underset{\textit{hash} \leftarrow \cH}{\Pr}[hash(q_j) = 0]\\
\end{align*}
Now we use (\ref{eq:hash_pr}) and obtain
\begin{align*}
\underset{\textit{hash} \leftarrow \cH}{\Pr}[X] =
\frac{1}{2(h+v)}\left(1 -\underset{\textit{hash} \leftarrow \cH}{\Pr}[\exists i < j : hash(q_i) = 0 \mid hash(q_j) = 0] \right)
\end{align*}
Using once more the property (\ref{eq:hash_pr})
\begin{align*}
\underset{\textit{hash} \leftarrow \cH}{\Pr}[X] = \frac{1}{2(h+v)} \left( 1 -\underset{\textit{hash} \leftarrow \cH}{\Pr}[\exists i < j : hash(q_i) = 0] \right).
\end{align*}
Finally, we use union bound and the fact $j \leq (h+v)$ to get
\begin{align*}
\underset{\textit{hash} \leftarrow \cH}{\Pr}[X] \geq
\frac{1}{2(h+v)} \left( 1 - \sum_{i < j} \underset{\textit{hash} \leftarrow \cH}{\Pr}[hash(q_i) = 0] \right) \geq \frac{1}{4(h+v)}
\end{align*}
Let $G$ denote the set of all $(\pi_1, \dots, \pi_k)$ for which $C$ succeeds in the random experiment $A$.
Then
\begin{align*}
\underset{\substack{\textit{hash} \leftarrow \cH \\ (\pi_1, \dots, \pi_k)}}{\Pr}[X] &=
\sum_{(\pi_1, \dots, \pi_k) \in G} \underset{\textit{hash} \leftarrow \cH}{\Pr}[X \mid (\widetilde{\pi}_1, \dots, \widetilde{\pi}_k)] \cdot \underset{(\widetilde{\pi}_1, \dots, \widetilde{\pi}_k)}{\Pr}[(\widetilde{\pi}_1, \dots, \widetilde{\pi}_k) = (\pi_1, \dots, \pi_k)]\\
&\geq \frac{1}{4(h+v)} \sum_{(\pi_1, \dots, \pi_k) \in G} \underset{(\widetilde{\pi}_1, \dots, \widetilde{\pi}_k)}{\Pr}[(\widetilde{\pi}_1, \dots, \widetilde{\pi}_k) = (\pi_1, \dots, \pi_k)] = \frac{\epsilon}{4(h+v)}
\end{align*}

\begin{codeblock}
  \textbf{Algorithm: FindHash} \\
  Pick a hash function with high canonical success probability
  \medskip

  \hrule

  \medskip

  %TODO define the circuit $C$ globally do not forget about limit on number of hint and verification queries
  \textbf{Oracle:} A solver circuit for $k$-wise direct product of DWVP $C^{(.),(.)}$ with oracle access to hint and verification oracle.\\
  %TODO better describe this hash functions
  \textbf{Input:} $\cH$ a family of pairwise independent hash functions $hash: Q \rightarrow \{0,1,\dots, 2(h+v)-1\}$  \\
  \medskip\hrule\medskip
  \linenumber{1}For $i = 1$ to $64(h+v)^2/\epsilon^2$ \\
  \linenumber{2}\IndI $hash \xleftarrow{\$} \cH$ \\
  \linenumber{3}\IndI $count := 0$ \\
  \linenumber{4}\IndI \For $j := 1$ to $64(h+v)^2/\epsilon^2$ \\
  \linenumber{5}\IndII $(\pi_1, \dots, \pi_k) \xleftarrow{\$} \{0,1\}^{kl} $\\
  \linenumber{6}\IndII $result := A^{P^{(g)},C^{(.), (.)}}(\pi_1, \dots, \pi_k)$\\
  \linenumber{7}\IndII \If $result = 1$\\
  \linenumber{8}\IndIII $count := count + 1$\\
  \linenumber{9}\IndI \If $count \geq 4(h+v)/\epsilon$ \\
  \linenumber{10}\IndII \return $hash$\\
  \linenumber{11}\return $\bot$
\end{codeblock}
We now show that the algorithm \textbf{FindHash} chooses a hash function such
that almost surly the success probability of $C$ in random experiment $E$
with respect to set $P_{hash}$ is at least $\frac{\epsilon}{4(h+v)}$.
From the fact that the random variable $X$ is binary distributed we have
\begin{align*}
  \underset{hash \leftarrow \cH}{\mathbb{E}}[X] \geq \frac{\epsilon}{4(h+v)}
\end{align*}
Let $\cH_{Good}$ denote the family of hash function for which $\underset{(\pi_1, \dots, \pi_k)}{\Pr}[X] \geq \frac{\epsilon}{4(h+v)}$.
and $X_i$ be a binary random variable such that
\begin{align*}
  X_i =
  \begin{cases}
    1 & \text{if in $i$th iteration $A^{P^{(g)}, C^{(.)(.)}} = 1$}\\
    0 & \text{otherwise .}
  \end{cases}
\end{align*}
We first show that it is unlikely that the algorithm \textbf{FindHash} returns $hash \notin \cH_{Good}$.
For $hash \notin \cH_{Good}$ we have $\mathbb{E}_{(\pi_1, \dots, \pi_k)}[X] < \frac{\epsilon}{4(h+v)}$.
We use Chernoff inequality and obtain
%FIXME write down the definition of $X_i$ correctly
%FIXME write the number over which you sum correctly
\begin{align*}
  \underset{(\pi_1, \dots, \pi_k)}{\Pr} \left[\frac{1}{N_i} \sum_{i=1}^{N_i} X_i \geq (1 + \delta) \frac{\epsilon}{4(h+v)} \right] \leq
  \underset{(\pi_1, \dots, \pi_k)}{\Pr}\left[\frac{1}{N_i} \sum_{i=1}^{N_i} X_i \geq (1 + \delta) \mathbb{E}[X]\right] \leq
  e^{-{\frac{\epsilon}{4(h+v)}} N_i \delta^2 /3}
\end{align*}
%
The probability that $hash \in \cH_{Good}$ is not returned by the algorithm is
\begin{align*}
  \underset{(\pi_1, \dots, \pi_k)}{\Pr}[\frac{1}{N_i} \sum_{i=1}^{N_i} X_i \leq (1 - \delta) \frac{\epsilon}{4(h+v)}] \leq
  \underset{(\pi_1, \dots, \pi_k)}{\Pr}[\frac{1}{N_i} \sum_{i=1}^{N_i} X_i \leq (1 - \delta) \mathbb{E}[X]] \leq e^{-{\frac{\epsilon}{4(h+v)}} N_i \delta^2 /3}
\end{align*}
%
Finally, we can similarly show that \textbf{FindHash} picks with high probability with one of its iteration a hash function that is in $\cH_{Good}$.
%
\end{proof}
%
%
\begin{lemma}\textbf{Security amplification of a dynamic weakly verifiable puzzle with respect to set $P_{hash}$.} \\
  For a fixed dynamic weakly verifiable puzzle $P^{(1)}$ there exists an algorithm\\
  $Gen(C, g, \varepsilon, \delta, n, v, h, Hash)$, which takes as input a circuit $C$, a monotone function $g$,
  a function $Hash : Q \rightarrow \{0, \dots, 2(h+v)-1\}$, parameters $\varepsilon, \delta, n$,
  number of verification $v$, and hint $h$ queries asked by $C$, and outputs a circuit $D$
  such that following holds: \\
  If $C$ is such that \\
  \begin{align*}
    \underset{(\pi_1, \dots, \pi_k)}{\Pr}[E^{P^{(g)}, C, Hash}(\pi_1, \dots, \pi_k)] \geq \underset{\mu \leftarrow \mu_\delta^k}{\Pr}[g(\mu) = 1] + \varepsilon
  \end{align*}
  then $D$ satisfies almost surely
  \begin{align*}
    \underset{\pi}{\Pr}[F^{P^{(1)},D, Hash}(\pi) = 1] \geq (\delta + \frac{\varepsilon}{6k})
  \end{align*}
  and $Size(D) \leq Size(C)\frac{6k}{\varepsilon}$ and $Time(Gen) = poly(k, \frac{1}{\varepsilon}, n, v, h)$.
\end{lemma}
%
%
\begin{codeblock}
  \textbf{Random experiment $F^{P^{(1)}, D, Hash}(\pi)$} \\
  Solving a single DWVP with respect to the set $P_{hash}$
  \medskip

  \hrule

  \medskip

  \textbf{Oracle:} A circuit D, a function $Hash$, a dynamic weakly verifiable puzzle $P^{(1)}$\\
  \textbf{Input:} Random bitstring $\pi$
  %TODO length of the bitstring maybe it is fixed as it is input to P^{(1)} ? like l see the end of the paper by Imaginazzo.
  \medskip\hrule\medskip

  $(x, \Gamma_v, \Gamma_H) := P^{(1)}(\pi)$ \\
  Run $D^{\Gamma_V, \Gamma_H}(x)$ \\
  \IndI Let $(\widetilde{q_j},\widetilde{r_j})$ be the first successful verification query if $D^{\Gamma_V, \Gamma_H}(x)$ succeeds or \\
  \IndI an arbitrary verification query when it fails.\\
  \textbf{If} $(\forall i < j :  Hash(q_i) \neq 0 )$ and $Hash(q_j) = 1$ \\
  \IndI \textbf{return} 1\\
  \textbf{else}\\
  \IndI \textbf{return} 0\\

\end{codeblock}
%
%
% \begin{codeblock}
%   \textbf{Random experiment $G^{Hash}(\pi_1, \dots, \pi_k)$}
%   Random experiment F on the photos
%   \medskip

%   \hrule

%   \medskip

%   \textbf{Oracle:} A function $Hash$ \\
%   \textbf{Input:} Random bitstring $\pi$
%   %TODO length of the bitstring maybe it is fixed as it is input to P^{(1)} ? like l see the end of the paper by Imaginazzo.
%   \medskip\hrule\medskip
%   \textbf{For} $i=1$ to $k$ \\
%   \IndI $(x, \Gamma_V^{(i)}, \Gamma_H^{(i)}) = P^{(1)}(\pi_i)$ \\
%   Let $\Gamma_V^{(g)} $ be a circuit computing $g(\Gamma_v^{(1)}(q, r_1), \dots, \Gamma_V^{(k)}(q, r_k))$ \\
%   Let $\Gamma_H^{(g)} $ be a circuit computing $(\Gamma_v^{(1)}(q, r_1), \dots, \Gamma_V^{(k)}(q, r_k))$ \\
%   $(q,\widetilde{r}) = \widetilde{C}^{\Gamma_V^{(g)}, \Gamma_H^{(g)}, Hash} (x_1, \dots, x_k)$ \\
%   \textbf{If} $(q, \widetilde{r}) = \bot$ then \textbf{return} $\bot$ \\
%   \textbf{For} $i = 1$ to $k$ \\
%   \IndI $c_i = \Gamma_V^{(i)}(q,r_i)$ \\
%   \textbf{Return} $(c_1, \dots, c_k)$
% \end{codeblock}

\begin{codeblock}
  \textbf{Circuit $\widetilde{C}^{\Gamma_V^{(g)}, \Gamma_H^{(g)}, Hash} (x_1, \dots, x_k)$} \\
  Circuit $\widetilde{C}$ has good canonical success probability.
  \medskip

  \hrule

  \medskip

  \textbf{Oracle:} $\Gamma_V^{(g)}, \Gamma_H^{(g)}, Hash$ \\
  \textbf{Input:} k-wise direct product of puzzles $(x_1, \dots, x_k)$ \\

  \medskip\hrule\medskip
  Run $C^{(.), (.)}(x_1, \dots, x_k)$ \\
  \IndI \textbf{If} $C$ asks hint query $q$ \textbf{then}\\
  \IndII \textbf{If} $Hash(q) = 0$ \textbf{then}\\
  \IndIII \textbf{return} $\bot$\\
  \IndII \textbf{else}\\
  \IndIII answer with $\Gamma_H^{(g)}(q)$\\
  \\
  \IndI \textbf{If} $C$ asks verification query $(q, y_1, \dots, y_k)$ \textbf{then} \\
  \IndII \textbf{If} $hash(q) = 0$ \textbf{then} \\
  \IndIII \textbf{return} $(q, y_1, \dots, y_k)$ \\
  \IndII \textbf{else} \\
  \IndIII answer verification query with 0
  \textbf{return} $\bot$
\end{codeblock}


\begin{lemma}
  \begin{align*}
  \underset{(\pi_1, \dots, \pi_k)}{\Pr}[E^{P^{(g)}, C, Hash}(\pi_1, \dots, \pi_k) = 1] \leq \underset{(\pi_1, \dots, \pi_k)}{\Pr}[\Gamma_V^{(g)} (\widetilde{C}^{\Gamma_V^{(g)}, \Gamma_H^{(g)}, Hash}(\pi_1, \dots, \pi_k)) = 1]
  \end{align*}
\end{lemma}

\begin{proof}
If $E^{P^{(g)}, C, Hash}(\pi_1, \dots, \pi_k) = 1$ then circuit $\Gamma_V^{(g)} (\widetilde{C}^{\Gamma_V^{(g)}, \Gamma_H^{(g)}, Hash}(\pi_1, \dots, \pi_k)) = 1$.
\end{proof}

\begin{codeblock}
  \textbf{Algorithm $Gen(\widetilde{C},g,\epsilon,\delta,n)$}
  \medskip

  \hrule

  \medskip

  \textbf{Oracle:} $\widetilde{C}, g$ \\
  \textbf{Input:}  $\epsilon, \delta, n$\\
  \textbf{Output:} A circuit $D$

  \medskip\hrule\medskip

  \textbf{For} $i:=1$ to $\frac{6k}{\epsilon}\log(n)$ \\
  \IndI $\pi* \leftarrow \{0,1\}^{l}$\\
  \IndI $\widetilde{S}_{\pi^*,0} := EvaluateSurplus(\pi^*, 0)$\\
  \IndI $\widetilde{S}_{\pi^*,1} := EvaluateSurplus(\pi^*, 1)$\\
  \IndI \textbf{If} $\widetilde{S}_{\pi^*,0} \geq (1 - \frac{3}{4k}) \epsilon$ or $\widetilde{S}_{\pi^*,1} \geq (1 - \frac{3}{4k}) \epsilon$ \\
  \IndII $\widetilde{C}' := \widetilde{C}$ with the first input fixed on $\pi^*$\\
  \IndII\textbf{return} $Gen(\widetilde{C}', g, \epsilon, \delta, n)$ \\
  // all estimates are lower than $(1-\frac{3}{4k})\varepsilon$\\
  $SolvePuzzle(\pi, \widetilde{C})$ \\
  \\
  \textbf{EvaluateSurplus}($\pi^*, b$) \\
  \IndI \textbf{For} $i:=1$ to $N_k$ \\
  \IndII $\pi^{(k)} \leftarrow \{0,1\}^{lk}$\\
  \IndII $(c_1, \dots, c_k) := EvalutePuzzles(\pi^*, \pi^{(k)})$\\
  \IndII $\widetilde{S}_{\pi^*,b}^i := g(b, c_2, \dots, c_k) - \underset{(u_2, \dots, u_k)}{\Pr}[b, u_2, \dots, u_k] $\\
  \IndI \textbf{return} $\frac{1}{N_k} \sum_{i=1}^{N_k} \widetilde{S}_{\pi^*,b}^i$\\
  \\
  \textbf{EvalutePuzzles}($\pi^*, \pi^{(k)}$)\\
  \IndI $(x^{k}, \Gamma_V^{(g)}, \Gamma_H^{(g)}) := P^{(g)}(\pi^*, \pi_2, \dots, \pi_k)$ \\
  \IndI \textbf{For} $i=2$ to $k$\\
  \IndII $(x_1, \Gamma_v^{(i)}, \Gamma_H^{(i)}) := P^{(1)}(\pi_i)$\\
  \IndI $(q,y^{k}) := \widetilde{C}^{\Gamma_V^{(g)}, \Gamma_H^{(g)}}(x^*, x_2, \dots, x_k)$\\
  \IndI \textbf{For} $i=1$ to $k$\\
  \IndII $c_i := \Gamma_v^{i}(q, y_i)$\\
  \IndI \textbf{return} $(c_1, \dots, c_k)$\\
\end{codeblock}

\begin{codeblock}
  \textbf{Circuit $D^{\widetilde{C}}$}
  \medskip

  \hrule

  \medskip

  \textbf{Oracle:}  $\widetilde{C}, P^{(1)}$\\

  \medskip\hrule\medskip
  \textbf{For} $i:=1$ to $\frac{6k}{\epsilon} \log(\frac{6k}{\epsilon})$\\
  \IndI $\pi^{k} \leftarrow \{0,1\}^{k}$\\
  \IndI $(c_1, \dots, c_k) := EvaluatePuzzles(\pi, \pi^{(k)})$\\
  \IndI \textbf{If} $g(1,c_2, \dots, c_k) = 1$ and $g(0,c_2, \dots, c_k) = 0$\\
  \IndII $(q, y_1, \dots, y_k) := \widetilde{C}(\pi^*, \pi_2, \dots, \pi_k)$\\
  \IndII \textbf{return} $y_1$\\
  \textbf{return} $\bot$ \\

\end{codeblock}

% \begin{codeblock}
%   \textbf{$\text{Estimates}_{\pi^*}$}
%   \medskip

%   \hrule

%   \medskip

%   \textbf{Oracle:}  \\
%   \textbf{Input:}  \\

%   \medskip\hrule\medskip
%   \textbf{For} $i = 1$ to  $\frac{6k}{\varepsilon} \log(n)$\\
%   \IndI $\pi_i^* := \{0,1\}^{l}$ \tab{ // $\pi_i^*$ is picked uniformly at random}\\
%   \IndI \textbf{For} $j = 1$ to $K$ \\
%   \IndII $\pi^{k} := \{0,1\}^{kl}$ \tab{// $\pi^{k}$ is picked uniformly at random}\\
%   \IndII $(c_2, \dots, c_k) := H^{\widetilde{C}^{\Gamma_V^{(g)}, \Gamma_H^{(g)}}, P^{(1)}}(\pi_i^*, \pi_2, \dots, \pi_k)$\\
%   \IndI $\widetilde{S}_{\pi_i^*,0}^j := g(0, c_2, \dots, c_k)$ \\
%   \IndI $\widetilde{S}_{\pi_i^*,1}^j := g(1, c_2, \dots, c_k)$ \\

% \end{codeblock}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "master.tex"
%%% End:
