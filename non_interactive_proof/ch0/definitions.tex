%FIXME is x a puzzle?
\begin{definition}[Dynamic weakly verifiable puzzle.]
  \label{def:dwvp}
  A dynamic weakly verifiable puzzle (DWVP) is defined by a probabilistic algorithm $P$
  called a problem poser.
  We denote by $P(\pi)$ the execution of $P$ with the randomness $\pi$.
  The algorithm $P$ outputs circuits $\Gamma_{V}$, $\Gamma_{H}$ and a puzzle $x \in \{0,1\}^{*}$.
  The circuit $\Gamma_{V}$ takes as input $q \in Q$, an answer $y \in \{0,1\}^*$,
  and outputs $1$ if $y$ is a correct solution of $x$ for $q$ and $0$ otherwise.
  The circuit $\Gamma_H$ on input $q \in Q$ outputs a hint such that $\Gamma_V(q,\Gamma_H(q)) = 1$.

  A problem solver $S$ is a probabilistic algorithm that takes as input a puzzle $x$,
  and has oracle access to $\Gamma_V$ and $\Gamma_H$.
  The randomness used by $S$ is denoted by $\rho$. The execution of $S$ with the input $x$ and the randomness $\rho$
  is denoted by $S(x, \rho)$. The queries of $S$ to $\Gamma_V$ are called verification queries, and to $\Gamma_H$ hint queries.
  The solver $S$ can ask at most $h$ hint queries, $v$ verification queries, and successfully solves the puzzle if and only if
  it makes a verification query $(q,y)$ such that $\Gamma_V(q,y) = 1$, when it has not previously asked for a hint query on $q$.
\end{definition}
%
%
\begin{definition}[$k$-wise direct-product of DWVPs.]
Let $g: \{0,1\}^{k} \rightarrow \{0,1\}$ be a monotone function and $P^{(1)}$ a problem poser as in Definition \ref{def:dwvp}.
The $k$-wise direct product of $P^{(1)}$ is a DWVP defined by a probabilistic algorithm $P^{(g)}$.
Let $\pi^{(k)} := (\pi_1, \dots, \pi_k)$ be the randomness used by $P^{(g)}$, and $P^{(g)}(\pi^{(k)})$ denote the execution of $P^{(g)}$ with the randomness $\pi^{(k)}$.
The poser $P^{(g)}$ outputs:
a verification circuit
\begin{align*}
  \Gamma_V^{(g)} (q, y_1, \dots, y_k) := g(\Gamma_V^{1}(q, y_1), \dots, \Gamma_V^{k}(q, y_k)),
\end{align*}
a hint circuit
\begin{align*}
  \Gamma_H^{(k)} (q) := (\Gamma_H^{1}(q), \dots, \Gamma_H^{k}(q)),
\end{align*}
and a puzzle $x^{(k)} := (x_1, \dots, x_k)$, where the $i$-th instance $(x_i, \Gamma_V^{i}, \Gamma_H^{i} ) := P^{(1)}(\pi_i)$.

% The probabilistic algorithm $S$, called a solver, takes as input $x^{(k)}$, random bitstring $\rho$, and has oracle access to $\Gamma_V^{(g)}, \Gamma_H^{(k)}$.
% The solver $S$ can ask at most $v$ verification queries to $\Gamma_V^{(g)}$, $h$ hint queries to $\Gamma_H^{(k)}$, and successfully solves the puzzle $x^{(k)}$
% if and only if it asks a verification query $(q, y^{(k)}) := (q, y_1, \dots, y_k)$ such that $\Gamma_V^{(g)}(q, y^{(k)}) = 1$, and has not previously asked for a hint query on this $q$.
\end{definition}
%
% A dynamic weakly verifiable puzzle is a special case of a $k$-wise direct product, when $k$ equals one and $g$ is the identity function.
We consider the following random experiment in which a $k$-wise direct product of DWVP defined by $P^{(k)}$ is solved by a circuit $C$.
The circuit $C$, takes as input $x^{(k)}$, random bitstring $\rho$, and has oracle access to $\Gamma^{(g)}_V, \Gamma^{(k)}_H$
%
\begin{codeblock}
  \textbf{Experiment $A^{P^{(k)}, C^{(\cdot, \cdot)}}(\pi^{(k)}, \rho)$}
  \medskip
  \hrule
  \medskip
  \textbf{Oracle:} A problem poser $P^{(k)}$, a solver circuit $C^{(\cdot,\cdot)}$.\\
  \textbf{Input:}  Bitstrings $\pi^{(k)}$, $\rho$.
  \medskip\hrule\medskip
  $(x^{(k)}, \Gamma_V^{(g)}, \Gamma_H^{(k)}) := P^{(k)}(\pi^{(k)})$ \\
  Run $C^{\Gamma_V^{(g)},\Gamma_H^{(k)}}(x^{(k)}, \rho)$ \\
  \IndI Let $Q_{Solved} := \{q: \text{$C^{\Gamma_V^{(g)}, \Gamma_H^{(k)}}$ asked a verification query $(q,y^{(k)})$ and $\Gamma_V^{(g)}(q, y^{(k)}) = 1$} \}$\\
  \IndI Let $Q_{Hint} := \{q: \text{$C^{\Gamma_V^{(g)}, \Gamma_H^{(k)}}$ asked a hint query on q} \}$\\
  \textbf{If} $\exists q \in Q_{solved} : q \notin Q_{Hint}$ \then \\
  \IndI \textbf{return} $1$\\
  \textbf{else} \\
  \IndI \textbf{return} $0$\\
\end{codeblock}
%
\begin{theorem}{\textbf{Security amplification for a dynamic weakly verifiable puzzle.}}
\label{th:sec_amp_for_dwvp}\\
For a fixed problem poser $P^{(1)}$ there exists an algorithm $Gen(C, g, \varepsilon, \delta, n, v, h)$ which takes as input a solver circuit $C$ for a $k$-wise
direct product of DWVP, a monotone function $g$, parameters $\varepsilon, \delta,n$, the number of verification $v$, and hint $h$ queries asked by $C$, and outputs a circuit $D$
such that following holds: \\
If $C$ is such that \\
  \begin{align*}
    \underset{\pi^{(k)}, \rho}{\Pr}[A^{P^{(g)}, C}(\pi^{(k)}, \rho) = 1]
    \geq \frac{(h+v)}{8} \left(\underset{\mu \leftarrow \mu_\delta^k}{\Pr}[g(\mu) = 1] + \varepsilon\right)
  \end{align*}
then $D$ satisfies almost surely
  \begin{align*}
    \underset{\pi, \rho}{\Pr}[A^{P^{(1)},D}(\pi, \rho) = 1] \geq (\delta + \frac{\varepsilon}{6k}).
  \end{align*}
Additionally, $D$ and $Gen$ require only oracle access to $g$ and $C$. Furthermore, $D$ asks at most $h$ hint queries, $v$ verification queries and
$Size(D) \leq Size(C) \cdot \Theta(\frac{6k}{\varepsilon})$ and $Time(Gen) = poly(k, \frac{1}{\varepsilon}, n, v, h)$.
\end{theorem}
%
% \begin{todo}
%   \textbf{TODO:} Is that entirely true? It also depends on the number of $(h+v)$ queries and its validity depends on the function, and function g(...) it may happen
%   that g is a constant then this theorem does not mean what was written here
% \end{todo}
% The Theorem \ref{th:sec_amp_for_dwvp} implies that if there is no good algorithm that solves DWVP,
% then a good algorithm for a $k$-wise direct product of DWVP does not exist.
%
Intuitively, the algorithm $Gen$ tries to find $k-1$ puzzles and a position for an input puzzle $x$, such that
when $C$ runs with the $k-1$ puzzles and $x$ placed on this position, then $x$ is often solved correctly.
To find a good position for $x$ and these $k-1$ puzzles $Gen$ needs to run $C$ several times.
In these runs $C$ asks a hint queries.
Let us assume that after some trials and errors $Gen$ finally finds a set of puzzles and a position for $x$ such that $x$ is often solved.
However, it may still not constitute a valid solution, as an additional requirement is needed that this happens often for $q$
on which a hint query was not asked before. To satisfy this requirement we split $Q$.
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../master"
%%% End:
